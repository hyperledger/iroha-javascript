/**
 * @module @iroha2/data-model
 */
/**
 * @packageDocumentation
 *
 * Iroha v2 data model codecs. Primarily contains the code generated by the `@scale-codec/definition-compiler`
 */

import * as datamodel from './datamodel/index'
import * as crypto from '@iroha2/crypto-core'

export { datamodel }
export * from './core'

export class ExtractQueryOutputError extends Error {
  public query: string
  public expectedOutput: string
  public actualOutput: string

  public constructor(query: string, expectedOutput: string, actualOutput: string) {
    // TODO: improve message
    super(
      `Failed to extract output of query "${query}": expected "${expectedOutput}" data type, got "${actualOutput}". This is a bug!`,
    )
  }
}

function extractQueryOutput<Q extends keyof datamodel.QueryOutputMap>(
  query: Q,
  response: datamodel.QueryResponse,
): datamodel.QueryOutputMap[Q]

function extractQueryOutput<Q extends keyof datamodel.SingularQueryOutputMap>(
  query: Q,
  response: datamodel.QueryResponse,
): datamodel.SingularQueryOutputMap[Q]

function extractQueryOutput(query: string, response: datamodel.QueryResponse) {
  if (query in datamodel.QueryOutputKindMap) {
    const outputKind = datamodel.QueryOutputKindMap[query as keyof datamodel.QueryOutputMap]
    if (response.t === 'Iterable' && response.value.batch.t === outputKind) return response.value.batch.value
    // throw good error
    throw new Error('unimplemented')
  }
  // todo do the same for singular
  throw new Error('unimplemented')
}

export { extractQueryOutput }

/**
 * The one that is used for e.g. {@link datamodel.TransactionEventFilter}
 */
export function transactionHash(tx: datamodel.SignedTransaction): crypto.Hash {
  const bytes = datamodel.SignedTransaction$codec.encode(tx)
  return crypto.Hash.hash(crypto.Bytes.array(bytes))
}

export function signQuery(
  payload: datamodel.QueryRequestWithAuthority,
  privateKey: crypto.PrivateKey,
): datamodel.SignedQuery {
  const payloadBytes = datamodel.QueryRequestWithAuthority$codec.encode(payload)
  const signature = privateKey.sign(crypto.Bytes.array(crypto.Hash.hash(crypto.Bytes.array(payloadBytes)).payload()))
  return {
    t: 'V1',
    value: {
      payload,
      signature: datamodel.Signature(signature),
    },
  }
}

export function signTransaction(
  payload: datamodel.TransactionPayload,
  privateKey: crypto.PrivateKey,
): datamodel.SignedTransaction {
  return crypto.freeScope(() => {
    const payloadBytes = datamodel.TransactionPayload$codec.encode(payload)
    const signature = privateKey.sign(crypto.Bytes.array(crypto.Hash.hash(crypto.Bytes.array(payloadBytes)).payload()))
    return {
      t: 'V1',
      value: {
        payload,
        signature: datamodel.Signature(signature),
      },
    }
  })
}
