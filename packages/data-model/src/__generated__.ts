import * as lib from './generated-prelude'
export type Account = { id: AccountId; assets: lib.codecs.Map<AssetDefinitionId, Asset>; metadata: Metadata; }
export const Account = lib.wrapCodec<Account>(lib.structCodec([['id', lib.toCodec(() => AccountId)], ['assets', lib.codecs.Map.with(lib.toCodec(() => AssetDefinitionId), lib.toCodec(() => Asset))], ['metadata', lib.toCodec(() => Metadata)]]))
export type AccountEvent = lib.Enumerate<{ Asset: [AssetEvent], Created: [Account], Deleted: [AccountId], AuthenticationAdded: [AccountId], AuthenticationRemoved: [AccountId], PermissionAdded: [AccountPermissionChanged], PermissionRemoved: [AccountPermissionChanged], RoleRevoked: [AccountRoleChanged], RoleGranted: [AccountRoleChanged], MetadataInserted: [MetadataChanged<AccountId>], MetadataRemoved: [MetadataChanged<AccountId>] }>
export const AccountEvent = { /** Produce `Asset` enum variant */ Asset: (value: AssetEvent): AccountEvent => lib.variant('Asset', value), /** Produce `Created` enum variant */ Created: (value: Account): AccountEvent => lib.variant('Created', value), /** Produce `Deleted` enum variant */ Deleted: (value: AccountId): AccountEvent => lib.variant('Deleted', value), /** Produce `AuthenticationAdded` enum variant */ AuthenticationAdded: (value: AccountId): AccountEvent => lib.variant('AuthenticationAdded', value), /** Produce `AuthenticationRemoved` enum variant */ AuthenticationRemoved: (value: AccountId): AccountEvent => lib.variant('AuthenticationRemoved', value), /** Produce `PermissionAdded` enum variant */ PermissionAdded: (value: AccountPermissionChanged): AccountEvent => lib.variant('PermissionAdded', value), /** Produce `PermissionRemoved` enum variant */ PermissionRemoved: (value: AccountPermissionChanged): AccountEvent => lib.variant('PermissionRemoved', value), /** Produce `RoleRevoked` enum variant */ RoleRevoked: (value: AccountRoleChanged): AccountEvent => lib.variant('RoleRevoked', value), /** Produce `RoleGranted` enum variant */ RoleGranted: (value: AccountRoleChanged): AccountEvent => lib.variant('RoleGranted', value), /** Produce `MetadataInserted` enum variant */ MetadataInserted: (value: MetadataChanged<AccountId>): AccountEvent => lib.variant('MetadataInserted', value), /** Produce `MetadataRemoved` enum variant */ MetadataRemoved: (value: MetadataChanged<AccountId>): AccountEvent => lib.variant('MetadataRemoved', value), [lib.symbolCodec]: lib.enumCodec<AccountEvent>([[0, 'Asset', lib.toCodec(() => AssetEvent)], [1, 'Created', lib.toCodec(() => Account)], [2, 'Deleted', lib.toCodec(() => AccountId)], [3, 'AuthenticationAdded', lib.toCodec(() => AccountId)], [4, 'AuthenticationRemoved', lib.toCodec(() => AccountId)], [5, 'PermissionAdded', lib.toCodec(() => AccountPermissionChanged)], [6, 'PermissionRemoved', lib.toCodec(() => AccountPermissionChanged)], [7, 'RoleRevoked', lib.toCodec(() => AccountRoleChanged)], [8, 'RoleGranted', lib.toCodec(() => AccountRoleChanged)], [9, 'MetadataInserted', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => AccountId)))], [10, 'MetadataRemoved', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => AccountId)))]]) }
export type AccountEventFilter = { idMatcher: lib.codecs.Option<AccountId>; eventSet: AccountEventSet; }
export const AccountEventFilter = lib.wrapCodec<AccountEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => AccountId))], ['eventSet', lib.toCodec(() => AccountEventSet)]]))
export type AccountEventSet = lib.codecs.U32
export const AccountEventSet = { /** `AnyAsset` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ AnyAsset: 1, /** `Created` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ Created: 2, /** `Deleted` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ Deleted: 4, /** `AuthenticationAdded` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ AuthenticationAdded: 8, /** `AuthenticationRemoved` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ AuthenticationRemoved: 16, /** `PermissionAdded` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ PermissionAdded: 32, /** `PermissionRemoved` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ PermissionRemoved: 64, /** `RoleRevoked` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ RoleRevoked: 128, /** `RoleGranted` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ RoleGranted: 256, /** `MetadataInserted` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ MetadataInserted: 512, /** `MetadataRemoved` event bitmask. Use `|` to combine with other {@link AccountEventSet} bitmasks. */ MetadataRemoved: 1024, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type AccountId = { domain: DomainId; signatory: PublicKey; }
export const AccountId = lib.wrapCodec<AccountId>(lib.structCodec([['domain', lib.toCodec(() => DomainId)], ['signatory', lib.toCodec(() => PublicKey)]]))
export type AccountPermissionChanged = { account: AccountId; permission: PermissionId; }
export const AccountPermissionChanged = lib.wrapCodec<AccountPermissionChanged>(lib.structCodec([['account', lib.toCodec(() => AccountId)], ['permission', lib.toCodec(() => PermissionId)]]))
export type AccountRoleChanged = { account: AccountId; role: RoleId; }
export const AccountRoleChanged = lib.wrapCodec<AccountRoleChanged>(lib.structCodec([['account', lib.toCodec(() => AccountId)], ['role', lib.toCodec(() => RoleId)]]))
export type Action = { executable: Executable; repeats: Repeats; authority: AccountId; filter: TriggeringEventFilterBox; metadata: Metadata; }
export const Action = lib.wrapCodec<Action>(lib.structCodec([['executable', lib.toCodec(() => Executable)], ['repeats', lib.toCodec(() => Repeats)], ['authority', lib.toCodec(() => AccountId)], ['filter', lib.toCodec(() => TriggeringEventFilterBox)], ['metadata', lib.toCodec(() => Metadata)]]))
export type Algorithm = lib.Enumerate<{ Ed25519: [], Secp256k1: [], BlsNormal: [], BlsSmall: [] }>
export const Algorithm = { /** `Ed25519` enum variant */ Ed25519: lib.variant<Algorithm>('Ed25519'), /** `Secp256k1` enum variant */ Secp256k1: lib.variant<Algorithm>('Secp256k1'), /** `BlsNormal` enum variant */ BlsNormal: lib.variant<Algorithm>('BlsNormal'), /** `BlsSmall` enum variant */ BlsSmall: lib.variant<Algorithm>('BlsSmall'), [lib.symbolCodec]: lib.enumCodec<Algorithm>([[0, 'Ed25519'], [1, 'Secp256k1'], [2, 'BlsNormal'], [3, 'BlsSmall']]) }
export type Asset = { id: AssetId; value: AssetValue; }
export const Asset = lib.wrapCodec<Asset>(lib.structCodec([['id', lib.toCodec(() => AssetId)], ['value', lib.toCodec(() => AssetValue)]]))
export type AssetChanged = { asset: AssetId; amount: AssetValue; }
export const AssetChanged = lib.wrapCodec<AssetChanged>(lib.structCodec([['asset', lib.toCodec(() => AssetId)], ['amount', lib.toCodec(() => AssetValue)]]))
export type AssetDefinition = { id: AssetDefinitionId; valueType: AssetValueType; mintable: Mintable; logo: lib.codecs.Option<IpfsPath>; metadata: Metadata; ownedBy: AccountId; }
export const AssetDefinition = lib.wrapCodec<AssetDefinition>(lib.structCodec([['id', lib.toCodec(() => AssetDefinitionId)], ['valueType', lib.toCodec(() => AssetValueType)], ['mintable', lib.toCodec(() => Mintable)], ['logo', lib.codecs.Option.with(lib.toCodec(() => IpfsPath))], ['metadata', lib.toCodec(() => Metadata)], ['ownedBy', lib.toCodec(() => AccountId)]]))
export type AssetDefinitionEvent = lib.Enumerate<{ Created: [AssetDefinition], MintabilityChanged: [AssetDefinitionId], OwnerChanged: [AssetDefinitionOwnerChanged], Deleted: [AssetDefinitionId], MetadataInserted: [MetadataChanged<AssetDefinitionId>], MetadataRemoved: [MetadataChanged<AssetDefinitionId>], TotalQuantityChanged: [AssetDefinitionTotalQuantityChanged] }>
export const AssetDefinitionEvent = { /** Produce `Created` enum variant */ Created: (value: AssetDefinition): AssetDefinitionEvent => lib.variant('Created', value), /** Produce `MintabilityChanged` enum variant */ MintabilityChanged: (value: AssetDefinitionId): AssetDefinitionEvent => lib.variant('MintabilityChanged', value), /** Produce `OwnerChanged` enum variant */ OwnerChanged: (value: AssetDefinitionOwnerChanged): AssetDefinitionEvent => lib.variant('OwnerChanged', value), /** Produce `Deleted` enum variant */ Deleted: (value: AssetDefinitionId): AssetDefinitionEvent => lib.variant('Deleted', value), /** Produce `MetadataInserted` enum variant */ MetadataInserted: (value: MetadataChanged<AssetDefinitionId>): AssetDefinitionEvent => lib.variant('MetadataInserted', value), /** Produce `MetadataRemoved` enum variant */ MetadataRemoved: (value: MetadataChanged<AssetDefinitionId>): AssetDefinitionEvent => lib.variant('MetadataRemoved', value), /** Produce `TotalQuantityChanged` enum variant */ TotalQuantityChanged: (value: AssetDefinitionTotalQuantityChanged): AssetDefinitionEvent => lib.variant('TotalQuantityChanged', value), [lib.symbolCodec]: lib.enumCodec<AssetDefinitionEvent>([[0, 'Created', lib.toCodec(() => AssetDefinition)], [1, 'MintabilityChanged', lib.toCodec(() => AssetDefinitionId)], [2, 'OwnerChanged', lib.toCodec(() => AssetDefinitionOwnerChanged)], [3, 'Deleted', lib.toCodec(() => AssetDefinitionId)], [4, 'MetadataInserted', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => AssetDefinitionId)))], [5, 'MetadataRemoved', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => AssetDefinitionId)))], [6, 'TotalQuantityChanged', lib.toCodec(() => AssetDefinitionTotalQuantityChanged)]]) }
export type AssetDefinitionEventFilter = { idMatcher: lib.codecs.Option<AssetDefinitionId>; eventSet: AssetDefinitionEventSet; }
export const AssetDefinitionEventFilter = lib.wrapCodec<AssetDefinitionEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => AssetDefinitionId))], ['eventSet', lib.toCodec(() => AssetDefinitionEventSet)]]))
export type AssetDefinitionEventSet = lib.codecs.U32
export const AssetDefinitionEventSet = { /** `Created` event bitmask. Use `|` to combine with other {@link AssetDefinitionEventSet} bitmasks. */ Created: 1, /** `MintabilityChanged` event bitmask. Use `|` to combine with other {@link AssetDefinitionEventSet} bitmasks. */ MintabilityChanged: 2, /** `OwnerChanged` event bitmask. Use `|` to combine with other {@link AssetDefinitionEventSet} bitmasks. */ OwnerChanged: 4, /** `Deleted` event bitmask. Use `|` to combine with other {@link AssetDefinitionEventSet} bitmasks. */ Deleted: 8, /** `MetadataInserted` event bitmask. Use `|` to combine with other {@link AssetDefinitionEventSet} bitmasks. */ MetadataInserted: 16, /** `MetadataRemoved` event bitmask. Use `|` to combine with other {@link AssetDefinitionEventSet} bitmasks. */ MetadataRemoved: 32, /** `TotalQuantityChanged` event bitmask. Use `|` to combine with other {@link AssetDefinitionEventSet} bitmasks. */ TotalQuantityChanged: 64, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type AssetDefinitionId = { domain: DomainId; name: lib.codecs.String; }
export const AssetDefinitionId = lib.wrapCodec<AssetDefinitionId>(lib.structCodec([['domain', lib.toCodec(() => DomainId)], ['name', lib.toCodec(lib.codecs.String)]]))
export type AssetDefinitionOwnerChanged = { assetDefinition: AssetDefinitionId; newOwner: AccountId; }
export const AssetDefinitionOwnerChanged = lib.wrapCodec<AssetDefinitionOwnerChanged>(lib.structCodec([['assetDefinition', lib.toCodec(() => AssetDefinitionId)], ['newOwner', lib.toCodec(() => AccountId)]]))
export type AssetDefinitionTotalQuantityChanged = { assetDefinition: AssetDefinitionId; totalAmount: Numeric; }
export const AssetDefinitionTotalQuantityChanged = lib.wrapCodec<AssetDefinitionTotalQuantityChanged>(lib.structCodec([['assetDefinition', lib.toCodec(() => AssetDefinitionId)], ['totalAmount', lib.toCodec(() => Numeric)]]))
export type AssetEvent = lib.Enumerate<{ Created: [Asset], Deleted: [AssetId], Added: [AssetChanged], Removed: [AssetChanged], MetadataInserted: [MetadataChanged<AssetId>], MetadataRemoved: [MetadataChanged<AssetId>] }>
export const AssetEvent = { /** Produce `Created` enum variant */ Created: (value: Asset): AssetEvent => lib.variant('Created', value), /** Produce `Deleted` enum variant */ Deleted: (value: AssetId): AssetEvent => lib.variant('Deleted', value), /** Produce `Added` enum variant */ Added: (value: AssetChanged): AssetEvent => lib.variant('Added', value), /** Produce `Removed` enum variant */ Removed: (value: AssetChanged): AssetEvent => lib.variant('Removed', value), /** Produce `MetadataInserted` enum variant */ MetadataInserted: (value: MetadataChanged<AssetId>): AssetEvent => lib.variant('MetadataInserted', value), /** Produce `MetadataRemoved` enum variant */ MetadataRemoved: (value: MetadataChanged<AssetId>): AssetEvent => lib.variant('MetadataRemoved', value), [lib.symbolCodec]: lib.enumCodec<AssetEvent>([[0, 'Created', lib.toCodec(() => Asset)], [1, 'Deleted', lib.toCodec(() => AssetId)], [2, 'Added', lib.toCodec(() => AssetChanged)], [3, 'Removed', lib.toCodec(() => AssetChanged)], [4, 'MetadataInserted', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => AssetId)))], [5, 'MetadataRemoved', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => AssetId)))]]) }
export type AssetEventFilter = { idMatcher: lib.codecs.Option<AssetId>; eventSet: AssetEventSet; }
export const AssetEventFilter = lib.wrapCodec<AssetEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => AssetId))], ['eventSet', lib.toCodec(() => AssetEventSet)]]))
export type AssetEventSet = lib.codecs.U32
export const AssetEventSet = { /** `Created` event bitmask. Use `|` to combine with other {@link AssetEventSet} bitmasks. */ Created: 1, /** `Deleted` event bitmask. Use `|` to combine with other {@link AssetEventSet} bitmasks. */ Deleted: 2, /** `Added` event bitmask. Use `|` to combine with other {@link AssetEventSet} bitmasks. */ Added: 4, /** `Removed` event bitmask. Use `|` to combine with other {@link AssetEventSet} bitmasks. */ Removed: 8, /** `MetadataInserted` event bitmask. Use `|` to combine with other {@link AssetEventSet} bitmasks. */ MetadataInserted: 16, /** `MetadataRemoved` event bitmask. Use `|` to combine with other {@link AssetEventSet} bitmasks. */ MetadataRemoved: 32, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type AssetId = { definition: AssetDefinitionId; account: AccountId; }
export const AssetId = lib.wrapCodec<AssetId>(lib.structCodec([['definition', lib.toCodec(() => AssetDefinitionId)], ['account', lib.toCodec(() => AccountId)]]))
export type AssetTransferBox = lib.Enumerate<{ Numeric: [Transfer<AssetId, Numeric, AccountId>], Store: [Transfer<AssetId, Metadata, AccountId>] }>
export const AssetTransferBox = { /** Produce `Numeric` enum variant */ Numeric: (value: Transfer<AssetId, Numeric, AccountId>): AssetTransferBox => lib.variant('Numeric', value), /** Produce `Store` enum variant */ Store: (value: Transfer<AssetId, Metadata, AccountId>): AssetTransferBox => lib.variant('Store', value), [lib.symbolCodec]: lib.enumCodec<AssetTransferBox>([[0, 'Numeric', lib.toCodec(() => Transfer.with(lib.toCodec(() => AssetId), lib.toCodec(() => Numeric), lib.toCodec(() => AccountId)))], [1, 'Store', lib.toCodec(() => Transfer.with(lib.toCodec(() => AssetId), lib.toCodec(() => Metadata), lib.toCodec(() => AccountId)))]]) }
export type AssetValue = lib.Enumerate<{ Numeric: [Numeric], Store: [Metadata] }>
export const AssetValue = { /** Produce `Numeric` enum variant */ Numeric: (value: Numeric): AssetValue => lib.variant('Numeric', value), /** Produce `Store` enum variant */ Store: (value: Metadata): AssetValue => lib.variant('Store', value), [lib.symbolCodec]: lib.enumCodec<AssetValue>([[0, 'Numeric', lib.toCodec(() => Numeric)], [1, 'Store', lib.toCodec(() => Metadata)]]) }
export type AssetValueType = lib.Enumerate<{ Numeric: [NumericSpec], Store: [] }>
export const AssetValueType = { /** Produce `Numeric` enum variant */ Numeric: (value: NumericSpec): AssetValueType => lib.variant('Numeric', value), /** `Store` enum variant */ Store: lib.variant<AssetValueType>('Store'), [lib.symbolCodec]: lib.enumCodec<AssetValueType>([[0, 'Numeric', lib.toCodec(() => NumericSpec)], [1, 'Store']]) }
export type AssetValueTypeMismatch = { expected: AssetValueType; actual: AssetValueType; }
export const AssetValueTypeMismatch = lib.wrapCodec<AssetValueTypeMismatch>(lib.structCodec([['expected', lib.toCodec(() => AssetValueType)], ['actual', lib.toCodec(() => AssetValueType)]]))
export type AtIndex = { index: lib.codecs.U32; predicate: QueryOutputPredicate; }
export const AtIndex = lib.wrapCodec<AtIndex>(lib.structCodec([['index', lib.toCodec(lib.codecs.U32)], ['predicate', lib.toCodec(() => QueryOutputPredicate)]]))
export type BatchedResponse = lib.Enumerate<{ V1: [BatchedResponseV1] }>
export const BatchedResponse = { /** Produce `V1` enum variant */ V1: (value: BatchedResponseV1): BatchedResponse => lib.variant('V1', value), [lib.symbolCodec]: lib.enumCodec<BatchedResponse>([[1, 'V1', lib.toCodec(() => BatchedResponseV1)]]) }
export type BatchedResponseV1 = { batch: QueryOutputBox; cursor: ForwardCursor; }
export const BatchedResponseV1 = lib.wrapCodec<BatchedResponseV1>(lib.structCodec([['batch', lib.toCodec(() => QueryOutputBox)], ['cursor', lib.toCodec(() => ForwardCursor)]]))
export type BlockEvent = { header: BlockHeader; hash: Hash; status: BlockStatus; }
export const BlockEvent = lib.wrapCodec<BlockEvent>(lib.structCodec([['header', lib.toCodec(() => BlockHeader)], ['hash', lib.toCodec(() => Hash)], ['status', lib.toCodec(() => BlockStatus)]]))
export type BlockEventFilter = { height: lib.codecs.Option<lib.codecs.U64>; status: lib.codecs.Option<BlockStatus>; }
export const BlockEventFilter = lib.wrapCodec<BlockEventFilter>(lib.structCodec([['height', lib.codecs.Option.with(lib.toCodec(lib.codecs.U64))], ['status', lib.codecs.Option.with(lib.toCodec(() => BlockStatus))]]))
export type BlockHeader = { height: lib.codecs.U64; prevBlockHash: lib.codecs.Option<Hash>; transactionsHash: Hash; timestampMs: lib.codecs.U64; viewChangeIndex: lib.codecs.U32; consensusEstimationMs: lib.codecs.U64; }
export const BlockHeader = lib.wrapCodec<BlockHeader>(lib.structCodec([['height', lib.toCodec(lib.codecs.U64)], ['prevBlockHash', lib.codecs.Option.with(lib.toCodec(() => Hash))], ['transactionsHash', lib.toCodec(() => Hash)], ['timestampMs', lib.toCodec(lib.codecs.U64)], ['viewChangeIndex', lib.toCodec(lib.codecs.U32)], ['consensusEstimationMs', lib.toCodec(lib.codecs.U64)]]))
export type BlockPayload = { header: BlockHeader; commitTopology: lib.codecs.Vec<PeerId>; transactions: lib.codecs.Vec<CommittedTransaction>; eventRecommendations: lib.codecs.Vec<EventBox>; }
export const BlockPayload = lib.wrapCodec<BlockPayload>(lib.structCodec([['header', lib.toCodec(() => BlockHeader)], ['commitTopology', lib.codecs.Vec.with(lib.toCodec(() => PeerId))], ['transactions', lib.codecs.Vec.with(lib.toCodec(() => CommittedTransaction))], ['eventRecommendations', lib.codecs.Vec.with(lib.toCodec(() => EventBox))]]))
export type BlockRejectionReason = lib.Enumerate<{ ConsensusBlockRejection: [] }>
export const BlockRejectionReason = { /** `ConsensusBlockRejection` enum variant */ ConsensusBlockRejection: lib.variant<BlockRejectionReason>('ConsensusBlockRejection'), [lib.symbolCodec]: lib.enumCodec<BlockRejectionReason>([[0, 'ConsensusBlockRejection']]) }
export type BlockSignature = { peerTopologyIndex: lib.codecs.U64; payload: BlockPayload; }
export const BlockSignature = lib.wrapCodec<BlockSignature>(lib.structCodec([['peerTopologyIndex', lib.toCodec(lib.codecs.U64)], ['payload', lib.toCodec(() => BlockPayload)]]))
export type BlockStatus = lib.Enumerate<{ Approved: [], Rejected: [BlockRejectionReason], Committed: [], Applied: [] }>
export const BlockStatus = { /** `Approved` enum variant */ Approved: lib.variant<BlockStatus>('Approved'), /** Produce `Rejected` enum variant */ Rejected: (value: BlockRejectionReason): BlockStatus => lib.variant('Rejected', value), /** `Committed` enum variant */ Committed: lib.variant<BlockStatus>('Committed'), /** `Applied` enum variant */ Applied: lib.variant<BlockStatus>('Applied'), [lib.symbolCodec]: lib.enumCodec<BlockStatus>([[0, 'Approved'], [1, 'Rejected', lib.toCodec(() => BlockRejectionReason)], [2, 'Committed'], [3, 'Applied']]) }
export type BlockSubscriptionRequest = { fromBlockHeight: lib.codecs.NonZero<lib.codecs.U64>; }
export const BlockSubscriptionRequest = lib.wrapCodec<BlockSubscriptionRequest>(lib.structCodec([['fromBlockHeight', lib.codecs.NonZero.with(lib.toCodec(lib.codecs.U64))]]))
export type Burn<T0, T1> = { object: T0, destination: T1 }
export const Burn = { with: <T0, T1>(codec0: lib.Codec<T0>,codec1: lib.Codec<T1>): lib.Codec<Burn<T0, T1>> => { return lib.structCodec([['object', codec0], ['destination', codec1]]) } }
export type BurnBox = lib.Enumerate<{ Asset: [Burn<Numeric, AssetId>], TriggerRepetitions: [Burn<lib.codecs.U32, TriggerId>] }>
export const BurnBox = { /** Produce `Asset` enum variant */ Asset: (value: Burn<Numeric, AssetId>): BurnBox => lib.variant('Asset', value), /** Produce `TriggerRepetitions` enum variant */ TriggerRepetitions: (value: Burn<lib.codecs.U32, TriggerId>): BurnBox => lib.variant('TriggerRepetitions', value), [lib.symbolCodec]: lib.enumCodec<BurnBox>([[0, 'Asset', lib.toCodec(() => Burn.with(lib.toCodec(() => Numeric), lib.toCodec(() => AssetId)))], [1, 'TriggerRepetitions', lib.toCodec(() => Burn.with(lib.toCodec(lib.codecs.U32), lib.toCodec(() => TriggerId)))]]) }
export type ClientQueryPayload = { authority: AccountId; query: QueryBox; filter: PredicateBox; sorting: Sorting; pagination: Pagination; fetchSize: FetchSize; }
export const ClientQueryPayload = lib.wrapCodec<ClientQueryPayload>(lib.structCodec([['authority', lib.toCodec(() => AccountId)], ['query', lib.toCodec(() => QueryBox)], ['filter', lib.toCodec(() => PredicateBox)], ['sorting', lib.toCodec(() => Sorting)], ['pagination', lib.toCodec(() => Pagination)], ['fetchSize', lib.toCodec(() => FetchSize)]]))
export type CommittedTransaction = { value: SignedTransaction; error: lib.codecs.Option<TransactionRejectionReason>; }
export const CommittedTransaction = lib.wrapCodec<CommittedTransaction>(lib.structCodec([['value', lib.toCodec(() => SignedTransaction)], ['error', lib.codecs.Option.with(lib.toCodec(() => TransactionRejectionReason))]]))
export type ConfigurationEvent = lib.Enumerate<{ Changed: [ParameterId], Created: [ParameterId], Deleted: [ParameterId] }>
export const ConfigurationEvent = { /** Produce `Changed` enum variant */ Changed: (value: ParameterId): ConfigurationEvent => lib.variant('Changed', value), /** Produce `Created` enum variant */ Created: (value: ParameterId): ConfigurationEvent => lib.variant('Created', value), /** Produce `Deleted` enum variant */ Deleted: (value: ParameterId): ConfigurationEvent => lib.variant('Deleted', value), [lib.symbolCodec]: lib.enumCodec<ConfigurationEvent>([[0, 'Changed', lib.toCodec(() => ParameterId)], [1, 'Created', lib.toCodec(() => ParameterId)], [2, 'Deleted', lib.toCodec(() => ParameterId)]]) }
export type ConfigurationEventFilter = { idMatcher: lib.codecs.Option<ParameterId>; eventSet: ConfigurationEventSet; }
export const ConfigurationEventFilter = lib.wrapCodec<ConfigurationEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => ParameterId))], ['eventSet', lib.toCodec(() => ConfigurationEventSet)]]))
export type ConfigurationEventSet = lib.codecs.U32
export const ConfigurationEventSet = { /** `Changed` event bitmask. Use `|` to combine with other {@link ConfigurationEventSet} bitmasks. */ Changed: 1, /** `Created` event bitmask. Use `|` to combine with other {@link ConfigurationEventSet} bitmasks. */ Created: 2, /** `Deleted` event bitmask. Use `|` to combine with other {@link ConfigurationEventSet} bitmasks. */ Deleted: 4, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type Container = lib.Enumerate<{ Any: [QueryOutputPredicate], All: [QueryOutputPredicate], AtIndex: [AtIndex] }>
export const Container = { /** Produce `Any` enum variant */ Any: (value: QueryOutputPredicate): Container => lib.variant('Any', value), /** Produce `All` enum variant */ All: (value: QueryOutputPredicate): Container => lib.variant('All', value), /** Produce `AtIndex` enum variant */ AtIndex: (value: AtIndex): Container => lib.variant('AtIndex', value), [lib.symbolCodec]: lib.enumCodec<Container>([[0, 'Any', lib.toCodec(() => QueryOutputPredicate)], [1, 'All', lib.toCodec(() => QueryOutputPredicate)], [2, 'AtIndex', lib.toCodec(() => AtIndex)]]) }
export type Custom = { payload: lib.codecs.Json; }
export const Custom = lib.wrapCodec<Custom>(lib.structCodec([['payload', lib.toCodec(lib.codecs.Json)]]))
export type DataEvent = lib.Enumerate<{ Peer: [PeerEvent], Domain: [DomainEvent], Trigger: [TriggerEvent], Role: [RoleEvent], Configuration: [ConfigurationEvent], Executor: [ExecutorEvent] }>
export const DataEvent = { /** Produce `Peer` enum variant */ Peer: (value: PeerEvent): DataEvent => lib.variant('Peer', value), /** Produce `Domain` enum variant */ Domain: (value: DomainEvent): DataEvent => lib.variant('Domain', value), /** Produce `Trigger` enum variant */ Trigger: (value: TriggerEvent): DataEvent => lib.variant('Trigger', value), /** Produce `Role` enum variant */ Role: (value: RoleEvent): DataEvent => lib.variant('Role', value), /** Produce `Configuration` enum variant */ Configuration: (value: ConfigurationEvent): DataEvent => lib.variant('Configuration', value), /** Produce `Executor` enum variant */ Executor: (value: ExecutorEvent): DataEvent => lib.variant('Executor', value), [lib.symbolCodec]: lib.enumCodec<DataEvent>([[0, 'Peer', lib.toCodec(() => PeerEvent)], [1, 'Domain', lib.toCodec(() => DomainEvent)], [2, 'Trigger', lib.toCodec(() => TriggerEvent)], [3, 'Role', lib.toCodec(() => RoleEvent)], [4, 'Configuration', lib.toCodec(() => ConfigurationEvent)], [5, 'Executor', lib.toCodec(() => ExecutorEvent)]]) }
export type DataEventFilter = lib.Enumerate<{ Any: [], Peer: [PeerEventFilter], Domain: [DomainEventFilter], Account: [AccountEventFilter], Asset: [AssetEventFilter], AssetDefinition: [AssetDefinitionEventFilter], Trigger: [TriggerEventFilter], Role: [RoleEventFilter], Configuration: [ConfigurationEventFilter], Executor: [ExecutorEventFilter] }>
export const DataEventFilter = { /** `Any` enum variant */ Any: lib.variant<DataEventFilter>('Any'), /** Produce `Peer` enum variant */ Peer: (value: PeerEventFilter): DataEventFilter => lib.variant('Peer', value), /** Produce `Domain` enum variant */ Domain: (value: DomainEventFilter): DataEventFilter => lib.variant('Domain', value), /** Produce `Account` enum variant */ Account: (value: AccountEventFilter): DataEventFilter => lib.variant('Account', value), /** Produce `Asset` enum variant */ Asset: (value: AssetEventFilter): DataEventFilter => lib.variant('Asset', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: AssetDefinitionEventFilter): DataEventFilter => lib.variant('AssetDefinition', value), /** Produce `Trigger` enum variant */ Trigger: (value: TriggerEventFilter): DataEventFilter => lib.variant('Trigger', value), /** Produce `Role` enum variant */ Role: (value: RoleEventFilter): DataEventFilter => lib.variant('Role', value), /** Produce `Configuration` enum variant */ Configuration: (value: ConfigurationEventFilter): DataEventFilter => lib.variant('Configuration', value), /** Produce `Executor` enum variant */ Executor: (value: ExecutorEventFilter): DataEventFilter => lib.variant('Executor', value), [lib.symbolCodec]: lib.enumCodec<DataEventFilter>([[0, 'Any'], [1, 'Peer', lib.toCodec(() => PeerEventFilter)], [2, 'Domain', lib.toCodec(() => DomainEventFilter)], [3, 'Account', lib.toCodec(() => AccountEventFilter)], [4, 'Asset', lib.toCodec(() => AssetEventFilter)], [5, 'AssetDefinition', lib.toCodec(() => AssetDefinitionEventFilter)], [6, 'Trigger', lib.toCodec(() => TriggerEventFilter)], [7, 'Role', lib.toCodec(() => RoleEventFilter)], [8, 'Configuration', lib.toCodec(() => ConfigurationEventFilter)], [9, 'Executor', lib.toCodec(() => ExecutorEventFilter)]]) }
export type Domain = { id: DomainId; accounts: lib.codecs.Map<AccountId, Account>; assetDefinitions: lib.codecs.Map<AssetDefinitionId, AssetDefinition>; assetTotalQuantities: lib.codecs.Map<AssetDefinitionId, Numeric>; logo: lib.codecs.Option<IpfsPath>; metadata: Metadata; ownedBy: AccountId; }
export const Domain = lib.wrapCodec<Domain>(lib.structCodec([['id', lib.toCodec(() => DomainId)], ['accounts', lib.codecs.Map.with(lib.toCodec(() => AccountId), lib.toCodec(() => Account))], ['assetDefinitions', lib.codecs.Map.with(lib.toCodec(() => AssetDefinitionId), lib.toCodec(() => AssetDefinition))], ['assetTotalQuantities', lib.codecs.Map.with(lib.toCodec(() => AssetDefinitionId), lib.toCodec(() => Numeric))], ['logo', lib.codecs.Option.with(lib.toCodec(() => IpfsPath))], ['metadata', lib.toCodec(() => Metadata)], ['ownedBy', lib.toCodec(() => AccountId)]]))
export type DomainEvent = lib.Enumerate<{ Account: [AccountEvent], AssetDefinition: [AssetDefinitionEvent], Created: [Domain], Deleted: [DomainId], MetadataInserted: [MetadataChanged<DomainId>], MetadataRemoved: [MetadataChanged<DomainId>], OwnerChanged: [DomainOwnerChanged] }>
export const DomainEvent = { /** Produce `Account` enum variant */ Account: (value: AccountEvent): DomainEvent => lib.variant('Account', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: AssetDefinitionEvent): DomainEvent => lib.variant('AssetDefinition', value), /** Produce `Created` enum variant */ Created: (value: Domain): DomainEvent => lib.variant('Created', value), /** Produce `Deleted` enum variant */ Deleted: (value: DomainId): DomainEvent => lib.variant('Deleted', value), /** Produce `MetadataInserted` enum variant */ MetadataInserted: (value: MetadataChanged<DomainId>): DomainEvent => lib.variant('MetadataInserted', value), /** Produce `MetadataRemoved` enum variant */ MetadataRemoved: (value: MetadataChanged<DomainId>): DomainEvent => lib.variant('MetadataRemoved', value), /** Produce `OwnerChanged` enum variant */ OwnerChanged: (value: DomainOwnerChanged): DomainEvent => lib.variant('OwnerChanged', value), [lib.symbolCodec]: lib.enumCodec<DomainEvent>([[0, 'Account', lib.toCodec(() => AccountEvent)], [1, 'AssetDefinition', lib.toCodec(() => AssetDefinitionEvent)], [2, 'Created', lib.toCodec(() => Domain)], [3, 'Deleted', lib.toCodec(() => DomainId)], [4, 'MetadataInserted', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => DomainId)))], [5, 'MetadataRemoved', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => DomainId)))], [6, 'OwnerChanged', lib.toCodec(() => DomainOwnerChanged)]]) }
export type DomainEventFilter = { idMatcher: lib.codecs.Option<DomainId>; eventSet: DomainEventSet; }
export const DomainEventFilter = lib.wrapCodec<DomainEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => DomainId))], ['eventSet', lib.toCodec(() => DomainEventSet)]]))
export type DomainEventSet = lib.codecs.U32
export const DomainEventSet = { /** `AnyAccount` event bitmask. Use `|` to combine with other {@link DomainEventSet} bitmasks. */ AnyAccount: 1, /** `AnyAssetDefinition` event bitmask. Use `|` to combine with other {@link DomainEventSet} bitmasks. */ AnyAssetDefinition: 2, /** `Created` event bitmask. Use `|` to combine with other {@link DomainEventSet} bitmasks. */ Created: 4, /** `Deleted` event bitmask. Use `|` to combine with other {@link DomainEventSet} bitmasks. */ Deleted: 8, /** `MetadataInserted` event bitmask. Use `|` to combine with other {@link DomainEventSet} bitmasks. */ MetadataInserted: 16, /** `MetadataRemoved` event bitmask. Use `|` to combine with other {@link DomainEventSet} bitmasks. */ MetadataRemoved: 32, /** `OwnerChanged` event bitmask. Use `|` to combine with other {@link DomainEventSet} bitmasks. */ OwnerChanged: 64, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type DomainId = { name: lib.codecs.String; }
export const DomainId = lib.wrapCodec<DomainId>(lib.structCodec([['name', lib.toCodec(lib.codecs.String)]]))
export type DomainOwnerChanged = { domain: DomainId; newOwner: AccountId; }
export const DomainOwnerChanged = lib.wrapCodec<DomainOwnerChanged>(lib.structCodec([['domain', lib.toCodec(() => DomainId)], ['newOwner', lib.toCodec(() => AccountId)]]))
export type Duration = { secs: lib.codecs.U64; nanos: lib.codecs.U32; }
export const Duration = lib.wrapCodec<Duration>(lib.structCodec([['secs', lib.toCodec(lib.codecs.U64)], ['nanos', lib.toCodec(lib.codecs.U32)]]))
export type EventBox = lib.Enumerate<{ Pipeline: [PipelineEventBox], Data: [DataEvent], Time: [TimeEvent], ExecuteTrigger: [ExecuteTriggerEvent], TriggerCompleted: [TriggerCompletedEvent] }>
export const EventBox = { /** Produce `Pipeline` enum variant */ Pipeline: (value: PipelineEventBox): EventBox => lib.variant('Pipeline', value), /** Produce `Data` enum variant */ Data: (value: DataEvent): EventBox => lib.variant('Data', value), /** Produce `Time` enum variant */ Time: (value: TimeEvent): EventBox => lib.variant('Time', value), /** Produce `ExecuteTrigger` enum variant */ ExecuteTrigger: (value: ExecuteTriggerEvent): EventBox => lib.variant('ExecuteTrigger', value), /** Produce `TriggerCompleted` enum variant */ TriggerCompleted: (value: TriggerCompletedEvent): EventBox => lib.variant('TriggerCompleted', value), [lib.symbolCodec]: lib.enumCodec<EventBox>([[0, 'Pipeline', lib.toCodec(() => PipelineEventBox)], [1, 'Data', lib.toCodec(() => DataEvent)], [2, 'Time', lib.toCodec(() => TimeEvent)], [3, 'ExecuteTrigger', lib.toCodec(() => ExecuteTriggerEvent)], [4, 'TriggerCompleted', lib.toCodec(() => TriggerCompletedEvent)]]) }
export type EventFilterBox = lib.Enumerate<{ Pipeline: [PipelineEventFilterBox], Data: [DataEventFilter], Time: [ExecutionTime], ExecuteTrigger: [ExecuteTriggerEventFilter], TriggerCompleted: [TriggerCompletedEventFilter] }>
export const EventFilterBox = { /** Produce `Pipeline` enum variant */ Pipeline: (value: PipelineEventFilterBox): EventFilterBox => lib.variant('Pipeline', value), /** Produce `Data` enum variant */ Data: (value: DataEventFilter): EventFilterBox => lib.variant('Data', value), /** Produce `Time` enum variant */ Time: (value: ExecutionTime): EventFilterBox => lib.variant('Time', value), /** Produce `ExecuteTrigger` enum variant */ ExecuteTrigger: (value: ExecuteTriggerEventFilter): EventFilterBox => lib.variant('ExecuteTrigger', value), /** Produce `TriggerCompleted` enum variant */ TriggerCompleted: (value: TriggerCompletedEventFilter): EventFilterBox => lib.variant('TriggerCompleted', value), [lib.symbolCodec]: lib.enumCodec<EventFilterBox>([[0, 'Pipeline', lib.toCodec(() => PipelineEventFilterBox)], [1, 'Data', lib.toCodec(() => DataEventFilter)], [2, 'Time', lib.toCodec(() => ExecutionTime)], [3, 'ExecuteTrigger', lib.toCodec(() => ExecuteTriggerEventFilter)], [4, 'TriggerCompleted', lib.toCodec(() => TriggerCompletedEventFilter)]]) }
export type EventSubscriptionRequest = { filters: lib.codecs.Vec<EventFilterBox>; }
export const EventSubscriptionRequest = lib.wrapCodec<EventSubscriptionRequest>(lib.structCodec([['filters', lib.codecs.Vec.with(lib.toCodec(() => EventFilterBox))]]))
export type Executable = lib.Enumerate<{ Instructions: [lib.codecs.Vec<InstructionBox>], Wasm: [WasmSmartContract] }>
export const Executable = { /** Produce `Instructions` enum variant */ Instructions: (value: lib.codecs.Vec<InstructionBox>): Executable => lib.variant('Instructions', value), /** Produce `Wasm` enum variant */ Wasm: (value: WasmSmartContract): Executable => lib.variant('Wasm', value), [lib.symbolCodec]: lib.enumCodec<Executable>([[0, 'Instructions', lib.codecs.Vec.with(lib.toCodec(() => InstructionBox))], [1, 'Wasm', lib.toCodec(() => WasmSmartContract)]]) }
export type ExecuteTrigger = { trigger: TriggerId; }
export const ExecuteTrigger = lib.wrapCodec<ExecuteTrigger>(lib.structCodec([['trigger', lib.toCodec(() => TriggerId)]]))
export type ExecuteTriggerEvent = { triggerId: TriggerId; authority: AccountId; }
export const ExecuteTriggerEvent = lib.wrapCodec<ExecuteTriggerEvent>(lib.structCodec([['triggerId', lib.toCodec(() => TriggerId)], ['authority', lib.toCodec(() => AccountId)]]))
export type ExecuteTriggerEventFilter = { triggerId: lib.codecs.Option<TriggerId>; authority: lib.codecs.Option<AccountId>; }
export const ExecuteTriggerEventFilter = lib.wrapCodec<ExecuteTriggerEventFilter>(lib.structCodec([['triggerId', lib.codecs.Option.with(lib.toCodec(() => TriggerId))], ['authority', lib.codecs.Option.with(lib.toCodec(() => AccountId))]]))
export type ExecutionTime = lib.Enumerate<{ PreCommit: [], Schedule: [Schedule] }>
export const ExecutionTime = { /** `PreCommit` enum variant */ PreCommit: lib.variant<ExecutionTime>('PreCommit'), /** Produce `Schedule` enum variant */ Schedule: (value: Schedule): ExecutionTime => lib.variant('Schedule', value), [lib.symbolCodec]: lib.enumCodec<ExecutionTime>([[0, 'PreCommit'], [1, 'Schedule', lib.toCodec(() => Schedule)]]) }
export type Executor = { wasm: WasmSmartContract; }
export const Executor = lib.wrapCodec<Executor>(lib.structCodec([['wasm', lib.toCodec(() => WasmSmartContract)]]))
export type ExecutorDataModel = { permissions: lib.codecs.Vec<PermissionId>; customInstruction: lib.codecs.Option<lib.codecs.String>; schema: lib.codecs.Json; }
export const ExecutorDataModel = lib.wrapCodec<ExecutorDataModel>(lib.structCodec([['permissions', lib.codecs.Vec.with(lib.toCodec(() => PermissionId))], ['customInstruction', lib.codecs.Option.with(lib.toCodec(lib.codecs.String))], ['schema', lib.toCodec(lib.codecs.Json)]]))
export type ExecutorEvent = lib.Enumerate<{ Upgraded: [ExecutorUpgrade] }>
export const ExecutorEvent = { /** Produce `Upgraded` enum variant */ Upgraded: (value: ExecutorUpgrade): ExecutorEvent => lib.variant('Upgraded', value), [lib.symbolCodec]: lib.enumCodec<ExecutorEvent>([[0, 'Upgraded', lib.toCodec(() => ExecutorUpgrade)]]) }
export type ExecutorEventFilter = { eventSet: ExecutorEventSet; }
export const ExecutorEventFilter = lib.wrapCodec<ExecutorEventFilter>(lib.structCodec([['eventSet', lib.toCodec(() => ExecutorEventSet)]]))
export type ExecutorEventSet = lib.codecs.U32
export const ExecutorEventSet = { /** `Upgraded` event bitmask. Use `|` to combine with other {@link ExecutorEventSet} bitmasks. */ Upgraded: 1, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type ExecutorUpgrade = { newDataModel: ExecutorDataModel; }
export const ExecutorUpgrade = lib.wrapCodec<ExecutorUpgrade>(lib.structCodec([['newDataModel', lib.toCodec(() => ExecutorDataModel)]]))
export type Fail = { message: lib.codecs.String; }
export const Fail = lib.wrapCodec<Fail>(lib.structCodec([['message', lib.toCodec(lib.codecs.String)]]))
export type FetchSize = { fetchSize: lib.codecs.Option<lib.codecs.NonZero<lib.codecs.U32>>; }
export const FetchSize = lib.wrapCodec<FetchSize>(lib.structCodec([['fetchSize', lib.codecs.Option.with(lib.codecs.NonZero.with(lib.toCodec(lib.codecs.U32)))]]))
export type FindAccountById = { id: AccountId; }
export const FindAccountById = lib.wrapCodec<FindAccountById>(lib.structCodec([['id', lib.toCodec(() => AccountId)]]))
export type FindAccountKeyValueByIdAndKey = { id: AccountId; key: lib.codecs.String; }
export const FindAccountKeyValueByIdAndKey = lib.wrapCodec<FindAccountKeyValueByIdAndKey>(lib.structCodec([['id', lib.toCodec(() => AccountId)], ['key', lib.toCodec(lib.codecs.String)]]))
export type FindAccountsByDomainId = { domainId: DomainId; }
export const FindAccountsByDomainId = lib.wrapCodec<FindAccountsByDomainId>(lib.structCodec([['domainId', lib.toCodec(() => DomainId)]]))
export type FindAccountsWithAsset = { assetDefinitionId: AssetDefinitionId; }
export const FindAccountsWithAsset = lib.wrapCodec<FindAccountsWithAsset>(lib.structCodec([['assetDefinitionId', lib.toCodec(() => AssetDefinitionId)]]))
export type FindAssetById = { id: AssetId; }
export const FindAssetById = lib.wrapCodec<FindAssetById>(lib.structCodec([['id', lib.toCodec(() => AssetId)]]))
export type FindAssetDefinitionById = { id: AssetDefinitionId; }
export const FindAssetDefinitionById = lib.wrapCodec<FindAssetDefinitionById>(lib.structCodec([['id', lib.toCodec(() => AssetDefinitionId)]]))
export type FindAssetDefinitionKeyValueByIdAndKey = { id: AssetDefinitionId; key: lib.codecs.String; }
export const FindAssetDefinitionKeyValueByIdAndKey = lib.wrapCodec<FindAssetDefinitionKeyValueByIdAndKey>(lib.structCodec([['id', lib.toCodec(() => AssetDefinitionId)], ['key', lib.toCodec(lib.codecs.String)]]))
export type FindAssetKeyValueByIdAndKey = { id: AssetId; key: lib.codecs.String; }
export const FindAssetKeyValueByIdAndKey = lib.wrapCodec<FindAssetKeyValueByIdAndKey>(lib.structCodec([['id', lib.toCodec(() => AssetId)], ['key', lib.toCodec(lib.codecs.String)]]))
export type FindAssetQuantityById = { id: AssetId; }
export const FindAssetQuantityById = lib.wrapCodec<FindAssetQuantityById>(lib.structCodec([['id', lib.toCodec(() => AssetId)]]))
export type FindAssetsByAccountId = { accountId: AccountId; }
export const FindAssetsByAccountId = lib.wrapCodec<FindAssetsByAccountId>(lib.structCodec([['accountId', lib.toCodec(() => AccountId)]]))
export type FindAssetsByAssetDefinitionId = { assetDefinitionId: AssetDefinitionId; }
export const FindAssetsByAssetDefinitionId = lib.wrapCodec<FindAssetsByAssetDefinitionId>(lib.structCodec([['assetDefinitionId', lib.toCodec(() => AssetDefinitionId)]]))
export type FindAssetsByDomainId = { domainId: DomainId; }
export const FindAssetsByDomainId = lib.wrapCodec<FindAssetsByDomainId>(lib.structCodec([['domainId', lib.toCodec(() => DomainId)]]))
export type FindAssetsByDomainIdAndAssetDefinitionId = { domainId: DomainId; assetDefinitionId: AssetDefinitionId; }
export const FindAssetsByDomainIdAndAssetDefinitionId = lib.wrapCodec<FindAssetsByDomainIdAndAssetDefinitionId>(lib.structCodec([['domainId', lib.toCodec(() => DomainId)], ['assetDefinitionId', lib.toCodec(() => AssetDefinitionId)]]))
export type FindAssetsByName = { name: lib.codecs.String; }
export const FindAssetsByName = lib.wrapCodec<FindAssetsByName>(lib.structCodec([['name', lib.toCodec(lib.codecs.String)]]))
export type FindBlockHeaderByHash = { hash: Hash; }
export const FindBlockHeaderByHash = lib.wrapCodec<FindBlockHeaderByHash>(lib.structCodec([['hash', lib.toCodec(() => Hash)]]))
export type FindDomainById = { id: DomainId; }
export const FindDomainById = lib.wrapCodec<FindDomainById>(lib.structCodec([['id', lib.toCodec(() => DomainId)]]))
export type FindDomainKeyValueByIdAndKey = { id: DomainId; key: lib.codecs.String; }
export const FindDomainKeyValueByIdAndKey = lib.wrapCodec<FindDomainKeyValueByIdAndKey>(lib.structCodec([['id', lib.toCodec(() => DomainId)], ['key', lib.toCodec(lib.codecs.String)]]))
export type FindError = lib.Enumerate<{ Asset: [AssetId], AssetDefinition: [AssetDefinitionId], Account: [AccountId], Domain: [DomainId], MetadataKey: [lib.codecs.String], Block: [Hash], Transaction: [Hash], Peer: [PeerId], Trigger: [TriggerId], Role: [RoleId], Permission: [PermissionId], Parameter: [ParameterId], PublicKey: [PublicKey] }>
export const FindError = { /** Produce `Asset` enum variant */ Asset: (value: AssetId): FindError => lib.variant('Asset', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: AssetDefinitionId): FindError => lib.variant('AssetDefinition', value), /** Produce `Account` enum variant */ Account: (value: AccountId): FindError => lib.variant('Account', value), /** Produce `Domain` enum variant */ Domain: (value: DomainId): FindError => lib.variant('Domain', value), /** Produce `MetadataKey` enum variant */ MetadataKey: (value: lib.codecs.String): FindError => lib.variant('MetadataKey', value), /** Produce `Block` enum variant */ Block: (value: Hash): FindError => lib.variant('Block', value), /** Produce `Transaction` enum variant */ Transaction: (value: Hash): FindError => lib.variant('Transaction', value), /** Produce `Peer` enum variant */ Peer: (value: PeerId): FindError => lib.variant('Peer', value), /** Produce `Trigger` enum variant */ Trigger: (value: TriggerId): FindError => lib.variant('Trigger', value), /** Produce `Role` enum variant */ Role: (value: RoleId): FindError => lib.variant('Role', value), /** Produce `Permission` enum variant */ Permission: (value: PermissionId): FindError => lib.variant('Permission', value), /** Produce `Parameter` enum variant */ Parameter: (value: ParameterId): FindError => lib.variant('Parameter', value), /** Produce `PublicKey` enum variant */ PublicKey: (value: PublicKey): FindError => lib.variant('PublicKey', value), [lib.symbolCodec]: lib.enumCodec<FindError>([[0, 'Asset', lib.toCodec(() => AssetId)], [1, 'AssetDefinition', lib.toCodec(() => AssetDefinitionId)], [2, 'Account', lib.toCodec(() => AccountId)], [3, 'Domain', lib.toCodec(() => DomainId)], [4, 'MetadataKey', lib.toCodec(lib.codecs.String)], [5, 'Block', lib.toCodec(() => Hash)], [6, 'Transaction', lib.toCodec(() => Hash)], [7, 'Peer', lib.toCodec(() => PeerId)], [8, 'Trigger', lib.toCodec(() => TriggerId)], [9, 'Role', lib.toCodec(() => RoleId)], [10, 'Permission', lib.toCodec(() => PermissionId)], [11, 'Parameter', lib.toCodec(() => ParameterId)], [12, 'PublicKey', lib.toCodec(() => PublicKey)]]) }
export type FindPermissionsByAccountId = { id: AccountId; }
export const FindPermissionsByAccountId = lib.wrapCodec<FindPermissionsByAccountId>(lib.structCodec([['id', lib.toCodec(() => AccountId)]]))
export type FindRoleByRoleId = { id: RoleId; }
export const FindRoleByRoleId = lib.wrapCodec<FindRoleByRoleId>(lib.structCodec([['id', lib.toCodec(() => RoleId)]]))
export type FindRolesByAccountId = { id: AccountId; }
export const FindRolesByAccountId = lib.wrapCodec<FindRolesByAccountId>(lib.structCodec([['id', lib.toCodec(() => AccountId)]]))
export type FindTotalAssetQuantityByAssetDefinitionId = { id: AssetDefinitionId; }
export const FindTotalAssetQuantityByAssetDefinitionId = lib.wrapCodec<FindTotalAssetQuantityByAssetDefinitionId>(lib.structCodec([['id', lib.toCodec(() => AssetDefinitionId)]]))
export type FindTransactionByHash = { hash: Hash; }
export const FindTransactionByHash = lib.wrapCodec<FindTransactionByHash>(lib.structCodec([['hash', lib.toCodec(() => Hash)]]))
export type FindTransactionsByAccountId = { accountId: AccountId; }
export const FindTransactionsByAccountId = lib.wrapCodec<FindTransactionsByAccountId>(lib.structCodec([['accountId', lib.toCodec(() => AccountId)]]))
export type FindTriggerById = { id: TriggerId; }
export const FindTriggerById = lib.wrapCodec<FindTriggerById>(lib.structCodec([['id', lib.toCodec(() => TriggerId)]]))
export type FindTriggerKeyValueByIdAndKey = { id: TriggerId; key: lib.codecs.String; }
export const FindTriggerKeyValueByIdAndKey = lib.wrapCodec<FindTriggerKeyValueByIdAndKey>(lib.structCodec([['id', lib.toCodec(() => TriggerId)], ['key', lib.toCodec(lib.codecs.String)]]))
export type FindTriggersByAuthorityDomainId = { domainId: DomainId; }
export const FindTriggersByAuthorityDomainId = lib.wrapCodec<FindTriggersByAuthorityDomainId>(lib.structCodec([['domainId', lib.toCodec(() => DomainId)]]))
export type FindTriggersByAuthorityId = { accountId: AccountId; }
export const FindTriggersByAuthorityId = lib.wrapCodec<FindTriggersByAuthorityId>(lib.structCodec([['accountId', lib.toCodec(() => AccountId)]]))
export type ForwardCursor = { queryId: lib.codecs.Option<lib.codecs.String>; cursor: lib.codecs.Option<lib.codecs.NonZero<lib.codecs.U64>>; }
export const ForwardCursor = lib.wrapCodec<ForwardCursor>(lib.structCodec([['queryId', lib.codecs.Option.with(lib.toCodec(lib.codecs.String))], ['cursor', lib.codecs.Option.with(lib.codecs.NonZero.with(lib.toCodec(lib.codecs.U64)))]]))
export type Grant<T0, T1> = { object: T0, destination: T1 }
export const Grant = { with: <T0, T1>(codec0: lib.Codec<T0>,codec1: lib.Codec<T1>): lib.Codec<Grant<T0, T1>> => { return lib.structCodec([['object', codec0], ['destination', codec1]]) } }
export type GrantBox = lib.Enumerate<{ Permission: [Grant<Permission, AccountId>], Role: [Grant<RoleId, AccountId>], RolePermission: [Grant<Permission, RoleId>] }>
export const GrantBox = { /** Produce `Permission` enum variant */ Permission: (value: Grant<Permission, AccountId>): GrantBox => lib.variant('Permission', value), /** Produce `Role` enum variant */ Role: (value: Grant<RoleId, AccountId>): GrantBox => lib.variant('Role', value), /** Produce `RolePermission` enum variant */ RolePermission: (value: Grant<Permission, RoleId>): GrantBox => lib.variant('RolePermission', value), [lib.symbolCodec]: lib.enumCodec<GrantBox>([[0, 'Permission', lib.toCodec(() => Grant.with(lib.toCodec(() => Permission), lib.toCodec(() => AccountId)))], [1, 'Role', lib.toCodec(() => Grant.with(lib.toCodec(() => RoleId), lib.toCodec(() => AccountId)))], [2, 'RolePermission', lib.toCodec(() => Grant.with(lib.toCodec(() => Permission), lib.toCodec(() => RoleId)))]]) }
export type Hash = lib.codecs.Array<lib.codecs.U8>
export const Hash = lib.wrapCodec<Hash>(lib.codecs.Array.with(lib.toCodec(lib.codecs.U8), 32))
export type IdBox = lib.Enumerate<{ DomainId: [DomainId], AccountId: [AccountId], AssetDefinitionId: [AssetDefinitionId], AssetId: [AssetId], PeerId: [PeerId], TriggerId: [TriggerId], RoleId: [RoleId], PermissionId: [PermissionId], ParameterId: [ParameterId] }>
export const IdBox = { /** Produce `DomainId` enum variant */ DomainId: (value: DomainId): IdBox => lib.variant('DomainId', value), /** Produce `AccountId` enum variant */ AccountId: (value: AccountId): IdBox => lib.variant('AccountId', value), /** Produce `AssetDefinitionId` enum variant */ AssetDefinitionId: (value: AssetDefinitionId): IdBox => lib.variant('AssetDefinitionId', value), /** Produce `AssetId` enum variant */ AssetId: (value: AssetId): IdBox => lib.variant('AssetId', value), /** Produce `PeerId` enum variant */ PeerId: (value: PeerId): IdBox => lib.variant('PeerId', value), /** Produce `TriggerId` enum variant */ TriggerId: (value: TriggerId): IdBox => lib.variant('TriggerId', value), /** Produce `RoleId` enum variant */ RoleId: (value: RoleId): IdBox => lib.variant('RoleId', value), /** Produce `PermissionId` enum variant */ PermissionId: (value: PermissionId): IdBox => lib.variant('PermissionId', value), /** Produce `ParameterId` enum variant */ ParameterId: (value: ParameterId): IdBox => lib.variant('ParameterId', value), [lib.symbolCodec]: lib.enumCodec<IdBox>([[0, 'DomainId', lib.toCodec(() => DomainId)], [1, 'AccountId', lib.toCodec(() => AccountId)], [2, 'AssetDefinitionId', lib.toCodec(() => AssetDefinitionId)], [3, 'AssetId', lib.toCodec(() => AssetId)], [4, 'PeerId', lib.toCodec(() => PeerId)], [5, 'TriggerId', lib.toCodec(() => TriggerId)], [6, 'RoleId', lib.toCodec(() => RoleId)], [7, 'PermissionId', lib.toCodec(() => PermissionId)], [8, 'ParameterId', lib.toCodec(() => ParameterId)]]) }
export type IdentifiableBox = lib.Enumerate<{ NewDomain: [NewDomain], NewAccount: [NewAccount], NewAssetDefinition: [NewAssetDefinition], NewRole: [NewRole], Peer: [Peer], Domain: [Domain], Account: [Account], AssetDefinition: [AssetDefinition], Asset: [Asset], Trigger: [Trigger], Role: [Role], Parameter: [Parameter] }>
export const IdentifiableBox = { /** Produce `NewDomain` enum variant */ NewDomain: (value: NewDomain): IdentifiableBox => lib.variant('NewDomain', value), /** Produce `NewAccount` enum variant */ NewAccount: (value: NewAccount): IdentifiableBox => lib.variant('NewAccount', value), /** Produce `NewAssetDefinition` enum variant */ NewAssetDefinition: (value: NewAssetDefinition): IdentifiableBox => lib.variant('NewAssetDefinition', value), /** Produce `NewRole` enum variant */ NewRole: (value: NewRole): IdentifiableBox => lib.variant('NewRole', value), /** Produce `Peer` enum variant */ Peer: (value: Peer): IdentifiableBox => lib.variant('Peer', value), /** Produce `Domain` enum variant */ Domain: (value: Domain): IdentifiableBox => lib.variant('Domain', value), /** Produce `Account` enum variant */ Account: (value: Account): IdentifiableBox => lib.variant('Account', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: AssetDefinition): IdentifiableBox => lib.variant('AssetDefinition', value), /** Produce `Asset` enum variant */ Asset: (value: Asset): IdentifiableBox => lib.variant('Asset', value), /** Produce `Trigger` enum variant */ Trigger: (value: Trigger): IdentifiableBox => lib.variant('Trigger', value), /** Produce `Role` enum variant */ Role: (value: Role): IdentifiableBox => lib.variant('Role', value), /** Produce `Parameter` enum variant */ Parameter: (value: Parameter): IdentifiableBox => lib.variant('Parameter', value), [lib.symbolCodec]: lib.enumCodec<IdentifiableBox>([[0, 'NewDomain', lib.toCodec(() => NewDomain)], [1, 'NewAccount', lib.toCodec(() => NewAccount)], [2, 'NewAssetDefinition', lib.toCodec(() => NewAssetDefinition)], [3, 'NewRole', lib.toCodec(() => NewRole)], [4, 'Peer', lib.toCodec(() => Peer)], [5, 'Domain', lib.toCodec(() => Domain)], [6, 'Account', lib.toCodec(() => Account)], [7, 'AssetDefinition', lib.toCodec(() => AssetDefinition)], [8, 'Asset', lib.toCodec(() => Asset)], [9, 'Trigger', lib.toCodec(() => Trigger)], [10, 'Role', lib.toCodec(() => Role)], [11, 'Parameter', lib.toCodec(() => Parameter)]]) }
export type InstructionBox = { enum: lib.Enumerate<{ Register: [RegisterBox], Unregister: [UnregisterBox], Mint: [MintBox], Burn: [BurnBox], Transfer: [TransferBox], SetKeyValue: [SetKeyValueBox], RemoveKeyValue: [RemoveKeyValueBox], Grant: [GrantBox], Revoke: [RevokeBox], ExecuteTrigger: [ExecuteTrigger], SetParameter: [SetParameter], NewParameter: [NewParameter], Upgrade: [Upgrade], Log: [Log], Custom: [Custom], Fail: [Fail] }> }
export const InstructionBox: lib.EnumBoxValue<InstructionBox> = { /** Produce `Register` enum variant */ Register: (value: RegisterBox): InstructionBox => ({ enum: lib.variant('Register', value) }), /** Produce `Unregister` enum variant */ Unregister: (value: UnregisterBox): InstructionBox => ({ enum: lib.variant('Unregister', value) }), /** Produce `Mint` enum variant */ Mint: (value: MintBox): InstructionBox => ({ enum: lib.variant('Mint', value) }), /** Produce `Burn` enum variant */ Burn: (value: BurnBox): InstructionBox => ({ enum: lib.variant('Burn', value) }), /** Produce `Transfer` enum variant */ Transfer: (value: TransferBox): InstructionBox => ({ enum: lib.variant('Transfer', value) }), /** Produce `SetKeyValue` enum variant */ SetKeyValue: (value: SetKeyValueBox): InstructionBox => ({ enum: lib.variant('SetKeyValue', value) }), /** Produce `RemoveKeyValue` enum variant */ RemoveKeyValue: (value: RemoveKeyValueBox): InstructionBox => ({ enum: lib.variant('RemoveKeyValue', value) }), /** Produce `Grant` enum variant */ Grant: (value: GrantBox): InstructionBox => ({ enum: lib.variant('Grant', value) }), /** Produce `Revoke` enum variant */ Revoke: (value: RevokeBox): InstructionBox => ({ enum: lib.variant('Revoke', value) }), /** Produce `ExecuteTrigger` enum variant */ ExecuteTrigger: (value: ExecuteTrigger): InstructionBox => ({ enum: lib.variant('ExecuteTrigger', value) }), /** Produce `SetParameter` enum variant */ SetParameter: (value: SetParameter): InstructionBox => ({ enum: lib.variant('SetParameter', value) }), /** Produce `NewParameter` enum variant */ NewParameter: (value: NewParameter): InstructionBox => ({ enum: lib.variant('NewParameter', value) }), /** Produce `Upgrade` enum variant */ Upgrade: (value: Upgrade): InstructionBox => ({ enum: lib.variant('Upgrade', value) }), /** Produce `Log` enum variant */ Log: (value: Log): InstructionBox => ({ enum: lib.variant('Log', value) }), /** Produce `Custom` enum variant */ Custom: (value: Custom): InstructionBox => ({ enum: lib.variant('Custom', value) }), /** Produce `Fail` enum variant */ Fail: (value: Fail): InstructionBox => ({ enum: lib.variant('Fail', value) }), [lib.symbolCodec]: lib.boxEnumCodec(lib.enumCodec<InstructionBox['enum']>([[0, 'Register', lib.toCodec(() => RegisterBox)], [1, 'Unregister', lib.toCodec(() => UnregisterBox)], [2, 'Mint', lib.toCodec(() => MintBox)], [3, 'Burn', lib.toCodec(() => BurnBox)], [4, 'Transfer', lib.toCodec(() => TransferBox)], [5, 'SetKeyValue', lib.toCodec(() => SetKeyValueBox)], [6, 'RemoveKeyValue', lib.toCodec(() => RemoveKeyValueBox)], [7, 'Grant', lib.toCodec(() => GrantBox)], [8, 'Revoke', lib.toCodec(() => RevokeBox)], [9, 'ExecuteTrigger', lib.toCodec(() => ExecuteTrigger)], [10, 'SetParameter', lib.toCodec(() => SetParameter)], [11, 'NewParameter', lib.toCodec(() => NewParameter)], [12, 'Upgrade', lib.toCodec(() => Upgrade)], [13, 'Log', lib.toCodec(() => Log)], [14, 'Custom', lib.toCodec(() => Custom)], [15, 'Fail', lib.toCodec(() => Fail)]])) }
export type InstructionEvaluationError = lib.Enumerate<{ Unsupported: [InstructionType], PermissionParameter: [lib.codecs.String], Type: [TypeError] }>
export const InstructionEvaluationError = { /** Produce `Unsupported` enum variant */ Unsupported: (value: InstructionType): InstructionEvaluationError => lib.variant('Unsupported', value), /** Produce `PermissionParameter` enum variant */ PermissionParameter: (value: lib.codecs.String): InstructionEvaluationError => lib.variant('PermissionParameter', value), /** Produce `Type` enum variant */ Type: (value: TypeError): InstructionEvaluationError => lib.variant('Type', value), [lib.symbolCodec]: lib.enumCodec<InstructionEvaluationError>([[0, 'Unsupported', lib.toCodec(() => InstructionType)], [1, 'PermissionParameter', lib.toCodec(lib.codecs.String)], [2, 'Type', lib.toCodec(() => TypeError)]]) }
export type InstructionExecutionError = lib.Enumerate<{ Evaluate: [InstructionEvaluationError], Query: [QueryExecutionFail], Conversion: [lib.codecs.String], Find: [FindError], Repetition: [RepetitionError], Mintability: [MintabilityError], Math: [MathError], Metadata: [MetadataError], Fail: [lib.codecs.String], InvalidParameter: [InvalidParameterError], InvariantViolation: [lib.codecs.String] }>
export const InstructionExecutionError = { /** Produce `Evaluate` enum variant */ Evaluate: (value: InstructionEvaluationError): InstructionExecutionError => lib.variant('Evaluate', value), /** Produce `Query` enum variant */ Query: (value: QueryExecutionFail): InstructionExecutionError => lib.variant('Query', value), /** Produce `Conversion` enum variant */ Conversion: (value: lib.codecs.String): InstructionExecutionError => lib.variant('Conversion', value), /** Produce `Find` enum variant */ Find: (value: FindError): InstructionExecutionError => lib.variant('Find', value), /** Produce `Repetition` enum variant */ Repetition: (value: RepetitionError): InstructionExecutionError => lib.variant('Repetition', value), /** Produce `Mintability` enum variant */ Mintability: (value: MintabilityError): InstructionExecutionError => lib.variant('Mintability', value), /** Produce `Math` enum variant */ Math: (value: MathError): InstructionExecutionError => lib.variant('Math', value), /** Produce `Metadata` enum variant */ Metadata: (value: MetadataError): InstructionExecutionError => lib.variant('Metadata', value), /** Produce `Fail` enum variant */ Fail: (value: lib.codecs.String): InstructionExecutionError => lib.variant('Fail', value), /** Produce `InvalidParameter` enum variant */ InvalidParameter: (value: InvalidParameterError): InstructionExecutionError => lib.variant('InvalidParameter', value), /** Produce `InvariantViolation` enum variant */ InvariantViolation: (value: lib.codecs.String): InstructionExecutionError => lib.variant('InvariantViolation', value), [lib.symbolCodec]: lib.enumCodec<InstructionExecutionError>([[0, 'Evaluate', lib.toCodec(() => InstructionEvaluationError)], [1, 'Query', lib.toCodec(() => QueryExecutionFail)], [2, 'Conversion', lib.toCodec(lib.codecs.String)], [3, 'Find', lib.toCodec(() => FindError)], [4, 'Repetition', lib.toCodec(() => RepetitionError)], [5, 'Mintability', lib.toCodec(() => MintabilityError)], [6, 'Math', lib.toCodec(() => MathError)], [7, 'Metadata', lib.toCodec(() => MetadataError)], [8, 'Fail', lib.toCodec(lib.codecs.String)], [9, 'InvalidParameter', lib.toCodec(() => InvalidParameterError)], [10, 'InvariantViolation', lib.toCodec(lib.codecs.String)]]) }
export type InstructionExecutionFail = { instruction: InstructionBox; reason: lib.codecs.String; }
export const InstructionExecutionFail = lib.wrapCodec<InstructionExecutionFail>(lib.structCodec([['instruction', lib.toCodec(() => InstructionBox)], ['reason', lib.toCodec(lib.codecs.String)]]))
export type InstructionType = lib.Enumerate<{ Register: [], Unregister: [], Mint: [], Burn: [], Transfer: [], SetKeyValue: [], RemoveKeyValue: [], Grant: [], Revoke: [], ExecuteTrigger: [], SetParameter: [], NewParameter: [], Upgrade: [], Log: [], Custom: [], Fail: [] }>
export const InstructionType = { /** `Register` enum variant */ Register: lib.variant<InstructionType>('Register'), /** `Unregister` enum variant */ Unregister: lib.variant<InstructionType>('Unregister'), /** `Mint` enum variant */ Mint: lib.variant<InstructionType>('Mint'), /** `Burn` enum variant */ Burn: lib.variant<InstructionType>('Burn'), /** `Transfer` enum variant */ Transfer: lib.variant<InstructionType>('Transfer'), /** `SetKeyValue` enum variant */ SetKeyValue: lib.variant<InstructionType>('SetKeyValue'), /** `RemoveKeyValue` enum variant */ RemoveKeyValue: lib.variant<InstructionType>('RemoveKeyValue'), /** `Grant` enum variant */ Grant: lib.variant<InstructionType>('Grant'), /** `Revoke` enum variant */ Revoke: lib.variant<InstructionType>('Revoke'), /** `ExecuteTrigger` enum variant */ ExecuteTrigger: lib.variant<InstructionType>('ExecuteTrigger'), /** `SetParameter` enum variant */ SetParameter: lib.variant<InstructionType>('SetParameter'), /** `NewParameter` enum variant */ NewParameter: lib.variant<InstructionType>('NewParameter'), /** `Upgrade` enum variant */ Upgrade: lib.variant<InstructionType>('Upgrade'), /** `Log` enum variant */ Log: lib.variant<InstructionType>('Log'), /** `Custom` enum variant */ Custom: lib.variant<InstructionType>('Custom'), /** `Fail` enum variant */ Fail: lib.variant<InstructionType>('Fail'), [lib.symbolCodec]: lib.enumCodec<InstructionType>([[0, 'Register'], [1, 'Unregister'], [2, 'Mint'], [3, 'Burn'], [4, 'Transfer'], [5, 'SetKeyValue'], [6, 'RemoveKeyValue'], [7, 'Grant'], [8, 'Revoke'], [9, 'ExecuteTrigger'], [10, 'SetParameter'], [11, 'NewParameter'], [12, 'Upgrade'], [13, 'Log'], [14, 'Custom'], [15, 'Fail']]) }
export type InvalidParameterError = lib.Enumerate<{ Wasm: [lib.codecs.String], NameLength: [], TimeTriggerInThePast: [] }>
export const InvalidParameterError = { /** Produce `Wasm` enum variant */ Wasm: (value: lib.codecs.String): InvalidParameterError => lib.variant('Wasm', value), /** `NameLength` enum variant */ NameLength: lib.variant<InvalidParameterError>('NameLength'), /** `TimeTriggerInThePast` enum variant */ TimeTriggerInThePast: lib.variant<InvalidParameterError>('TimeTriggerInThePast'), [lib.symbolCodec]: lib.enumCodec<InvalidParameterError>([[0, 'Wasm', lib.toCodec(lib.codecs.String)], [1, 'NameLength'], [2, 'TimeTriggerInThePast']]) }
export type IpfsPath = { path: lib.codecs.String; }
export const IpfsPath = lib.wrapCodec<IpfsPath>(lib.structCodec([['path', lib.toCodec(lib.codecs.String)]]))
export type Ipv4Addr = lib.codecs.Array<lib.codecs.U8>
export const Ipv4Addr = lib.wrapCodec<Ipv4Addr>(lib.codecs.Array.with(lib.toCodec(lib.codecs.U8), 4))
export type Ipv6Addr = lib.codecs.Array<lib.codecs.U16>
export const Ipv6Addr = lib.wrapCodec<Ipv6Addr>(lib.codecs.Array.with(lib.toCodec(lib.codecs.U16), 8))
export type LengthLimits = { min: lib.codecs.U32; max: lib.codecs.U32; }
export const LengthLimits = lib.wrapCodec<LengthLimits>(lib.structCodec([['min', lib.toCodec(lib.codecs.U32)], ['max', lib.toCodec(lib.codecs.U32)]]))
export type Level = lib.Enumerate<{ TRACE: [], DEBUG: [], INFO: [], WARN: [], ERROR: [] }>
export const Level = { /** `TRACE` enum variant */ TRACE: lib.variant<Level>('TRACE'), /** `DEBUG` enum variant */ DEBUG: lib.variant<Level>('DEBUG'), /** `INFO` enum variant */ INFO: lib.variant<Level>('INFO'), /** `WARN` enum variant */ WARN: lib.variant<Level>('WARN'), /** `ERROR` enum variant */ ERROR: lib.variant<Level>('ERROR'), [lib.symbolCodec]: lib.enumCodec<Level>([[0, 'TRACE'], [1, 'DEBUG'], [2, 'INFO'], [3, 'WARN'], [4, 'ERROR']]) }
export type Limits = { capacity: lib.codecs.U32; maxEntryLen: lib.codecs.U32; }
export const Limits = lib.wrapCodec<Limits>(lib.structCodec([['capacity', lib.toCodec(lib.codecs.U32)], ['maxEntryLen', lib.toCodec(lib.codecs.U32)]]))
export type Log = { level: Level; msg: lib.codecs.String; }
export const Log = lib.wrapCodec<Log>(lib.structCodec([['level', lib.toCodec(() => Level)], ['msg', lib.toCodec(lib.codecs.String)]]))
export type MathError = lib.Enumerate<{ Overflow: [], NotEnoughQuantity: [], DivideByZero: [], NegativeValue: [], DomainViolation: [], Unknown: [], FixedPointConversion: [lib.codecs.String] }>
export const MathError = { /** `Overflow` enum variant */ Overflow: lib.variant<MathError>('Overflow'), /** `NotEnoughQuantity` enum variant */ NotEnoughQuantity: lib.variant<MathError>('NotEnoughQuantity'), /** `DivideByZero` enum variant */ DivideByZero: lib.variant<MathError>('DivideByZero'), /** `NegativeValue` enum variant */ NegativeValue: lib.variant<MathError>('NegativeValue'), /** `DomainViolation` enum variant */ DomainViolation: lib.variant<MathError>('DomainViolation'), /** `Unknown` enum variant */ Unknown: lib.variant<MathError>('Unknown'), /** Produce `FixedPointConversion` enum variant */ FixedPointConversion: (value: lib.codecs.String): MathError => lib.variant('FixedPointConversion', value), [lib.symbolCodec]: lib.enumCodec<MathError>([[0, 'Overflow'], [1, 'NotEnoughQuantity'], [2, 'DivideByZero'], [3, 'NegativeValue'], [4, 'DomainViolation'], [5, 'Unknown'], [6, 'FixedPointConversion', lib.toCodec(lib.codecs.String)]]) }
export type Metadata = lib.codecs.Map<lib.codecs.String, MetadataValueBox>
export const Metadata = lib.wrapCodec<Metadata>(lib.codecs.Map.with(lib.toCodec(lib.codecs.String), lib.toCodec(() => MetadataValueBox)))
export type MetadataChanged<T0> = { target: T0, key: lib.codecs.String, value: MetadataValueBox }
export const MetadataChanged = { with: <T0>(codec0: lib.Codec<T0>): lib.Codec<MetadataChanged<T0>> => { return lib.structCodec([['target', codec0], ['key', lib.toCodec(lib.codecs.String)], ['value', lib.toCodec(() => MetadataValueBox)]]) } }
export type MetadataError = lib.Enumerate<{ EmptyPath: [], EntryTooBig: [SizeError], MaxCapacity: [SizeError], MissingSegment: [lib.codecs.String], InvalidSegment: [lib.codecs.String] }>
export const MetadataError = { /** `EmptyPath` enum variant */ EmptyPath: lib.variant<MetadataError>('EmptyPath'), /** Produce `EntryTooBig` enum variant */ EntryTooBig: (value: SizeError): MetadataError => lib.variant('EntryTooBig', value), /** Produce `MaxCapacity` enum variant */ MaxCapacity: (value: SizeError): MetadataError => lib.variant('MaxCapacity', value), /** Produce `MissingSegment` enum variant */ MissingSegment: (value: lib.codecs.String): MetadataError => lib.variant('MissingSegment', value), /** Produce `InvalidSegment` enum variant */ InvalidSegment: (value: lib.codecs.String): MetadataError => lib.variant('InvalidSegment', value), [lib.symbolCodec]: lib.enumCodec<MetadataError>([[0, 'EmptyPath'], [1, 'EntryTooBig', lib.toCodec(() => SizeError)], [2, 'MaxCapacity', lib.toCodec(() => SizeError)], [3, 'MissingSegment', lib.toCodec(lib.codecs.String)], [4, 'InvalidSegment', lib.toCodec(lib.codecs.String)]]) }
export type MetadataValueBox = { enum: lib.Enumerate<{ Bool: [lib.codecs.Bool], String: [lib.codecs.String], Name: [lib.codecs.String], Bytes: [lib.codecs.BytesVec], Numeric: [Numeric], LimitedMetadata: [Metadata], Vec: [lib.codecs.Vec<MetadataValueBox>] }> }
export const MetadataValueBox: lib.EnumBoxValue<MetadataValueBox> = { /** Produce `Bool` enum variant */ Bool: (value: lib.codecs.Bool): MetadataValueBox => ({ enum: lib.variant('Bool', value) }), /** Produce `String` enum variant */ String: (value: lib.codecs.String): MetadataValueBox => ({ enum: lib.variant('String', value) }), /** Produce `Name` enum variant */ Name: (value: lib.codecs.String): MetadataValueBox => ({ enum: lib.variant('Name', value) }), /** Produce `Bytes` enum variant */ Bytes: (value: lib.codecs.BytesVec): MetadataValueBox => ({ enum: lib.variant('Bytes', value) }), /** Produce `Numeric` enum variant */ Numeric: (value: Numeric): MetadataValueBox => ({ enum: lib.variant('Numeric', value) }), /** Produce `LimitedMetadata` enum variant */ LimitedMetadata: (value: Metadata): MetadataValueBox => ({ enum: lib.variant('LimitedMetadata', value) }), /** Produce `Vec` enum variant */ Vec: (value: lib.codecs.Vec<MetadataValueBox>): MetadataValueBox => ({ enum: lib.variant('Vec', value) }), [lib.symbolCodec]: lib.boxEnumCodec(lib.enumCodec<MetadataValueBox['enum']>([[0, 'Bool', lib.toCodec(lib.codecs.Bool)], [1, 'String', lib.toCodec(lib.codecs.String)], [2, 'Name', lib.toCodec(lib.codecs.String)], [3, 'Bytes', lib.toCodec(lib.codecs.BytesVec)], [4, 'Numeric', lib.toCodec(() => Numeric)], [5, 'LimitedMetadata', lib.toCodec(() => Metadata)], [6, 'Vec', lib.codecs.Vec.with(lib.toCodec(() => MetadataValueBox))]])) }
export type Mint<T0, T1> = { object: T0, destination: T1 }
export const Mint = { with: <T0, T1>(codec0: lib.Codec<T0>,codec1: lib.Codec<T1>): lib.Codec<Mint<T0, T1>> => { return lib.structCodec([['object', codec0], ['destination', codec1]]) } }
export type MintBox = lib.Enumerate<{ Asset: [Mint<Numeric, AssetId>], TriggerRepetitions: [Mint<lib.codecs.U32, TriggerId>] }>
export const MintBox = { /** Produce `Asset` enum variant */ Asset: (value: Mint<Numeric, AssetId>): MintBox => lib.variant('Asset', value), /** Produce `TriggerRepetitions` enum variant */ TriggerRepetitions: (value: Mint<lib.codecs.U32, TriggerId>): MintBox => lib.variant('TriggerRepetitions', value), [lib.symbolCodec]: lib.enumCodec<MintBox>([[0, 'Asset', lib.toCodec(() => Mint.with(lib.toCodec(() => Numeric), lib.toCodec(() => AssetId)))], [1, 'TriggerRepetitions', lib.toCodec(() => Mint.with(lib.toCodec(lib.codecs.U32), lib.toCodec(() => TriggerId)))]]) }
export type MintabilityError = lib.Enumerate<{ MintUnmintable: [], ForbidMintOnMintable: [] }>
export const MintabilityError = { /** `MintUnmintable` enum variant */ MintUnmintable: lib.variant<MintabilityError>('MintUnmintable'), /** `ForbidMintOnMintable` enum variant */ ForbidMintOnMintable: lib.variant<MintabilityError>('ForbidMintOnMintable'), [lib.symbolCodec]: lib.enumCodec<MintabilityError>([[0, 'MintUnmintable'], [1, 'ForbidMintOnMintable']]) }
export type Mintable = lib.Enumerate<{ Infinitely: [], Once: [], Not: [] }>
export const Mintable = { /** `Infinitely` enum variant */ Infinitely: lib.variant<Mintable>('Infinitely'), /** `Once` enum variant */ Once: lib.variant<Mintable>('Once'), /** `Not` enum variant */ Not: lib.variant<Mintable>('Not'), [lib.symbolCodec]: lib.enumCodec<Mintable>([[0, 'Infinitely'], [1, 'Once'], [2, 'Not']]) }
export type NewAccount = { id: AccountId; metadata: Metadata; }
export const NewAccount = lib.wrapCodec<NewAccount>(lib.structCodec([['id', lib.toCodec(() => AccountId)], ['metadata', lib.toCodec(() => Metadata)]]))
export type NewAssetDefinition = { id: AssetDefinitionId; valueType: AssetValueType; mintable: Mintable; logo: lib.codecs.Option<IpfsPath>; metadata: Metadata; }
export const NewAssetDefinition = lib.wrapCodec<NewAssetDefinition>(lib.structCodec([['id', lib.toCodec(() => AssetDefinitionId)], ['valueType', lib.toCodec(() => AssetValueType)], ['mintable', lib.toCodec(() => Mintable)], ['logo', lib.codecs.Option.with(lib.toCodec(() => IpfsPath))], ['metadata', lib.toCodec(() => Metadata)]]))
export type NewDomain = { id: DomainId; logo: lib.codecs.Option<IpfsPath>; metadata: Metadata; }
export const NewDomain = lib.wrapCodec<NewDomain>(lib.structCodec([['id', lib.toCodec(() => DomainId)], ['logo', lib.codecs.Option.with(lib.toCodec(() => IpfsPath))], ['metadata', lib.toCodec(() => Metadata)]]))
export type NewParameter = { parameter: Parameter; }
export const NewParameter = lib.wrapCodec<NewParameter>(lib.structCodec([['parameter', lib.toCodec(() => Parameter)]]))
export type NewRole = { inner: Role; }
export const NewRole = lib.wrapCodec<NewRole>(lib.structCodec([['inner', lib.toCodec(() => Role)]]))
export type NonTrivial = lib.codecs.Vec<PredicateBox>
export const NonTrivial = lib.wrapCodec<NonTrivial>(lib.codecs.Vec.with(lib.toCodec(() => PredicateBox)))
export type Numeric = { mantissa: lib.codecs.Compact; scale: lib.codecs.Compact; }
export const Numeric = lib.wrapCodec<Numeric>(lib.structCodec([['mantissa', lib.toCodec(lib.codecs.Compact)], ['scale', lib.toCodec(lib.codecs.Compact)]]))
export type NumericSpec = { scale: lib.codecs.Option<lib.codecs.U32>; }
export const NumericSpec = lib.wrapCodec<NumericSpec>(lib.structCodec([['scale', lib.codecs.Option.with(lib.toCodec(lib.codecs.U32))]]))
export type Pagination = { limit: lib.codecs.Option<lib.codecs.NonZero<lib.codecs.U32>>; start: lib.codecs.Option<lib.codecs.NonZero<lib.codecs.U64>>; }
export const Pagination = lib.wrapCodec<Pagination>(lib.structCodec([['limit', lib.codecs.Option.with(lib.codecs.NonZero.with(lib.toCodec(lib.codecs.U32)))], ['start', lib.codecs.Option.with(lib.codecs.NonZero.with(lib.toCodec(lib.codecs.U64)))]]))
export type Parameter = { id: ParameterId; val: ParameterValueBox; }
export const Parameter = lib.wrapCodec<Parameter>(lib.structCodec([['id', lib.toCodec(() => ParameterId)], ['val', lib.toCodec(() => ParameterValueBox)]]))
export type ParameterId = { name: lib.codecs.String; }
export const ParameterId = lib.wrapCodec<ParameterId>(lib.structCodec([['name', lib.toCodec(lib.codecs.String)]]))
export type ParameterValueBox = lib.Enumerate<{ TransactionLimits: [TransactionLimits], MetadataLimits: [Limits], LengthLimits: [LengthLimits], Numeric: [Numeric] }>
export const ParameterValueBox = { /** Produce `TransactionLimits` enum variant */ TransactionLimits: (value: TransactionLimits): ParameterValueBox => lib.variant('TransactionLimits', value), /** Produce `MetadataLimits` enum variant */ MetadataLimits: (value: Limits): ParameterValueBox => lib.variant('MetadataLimits', value), /** Produce `LengthLimits` enum variant */ LengthLimits: (value: LengthLimits): ParameterValueBox => lib.variant('LengthLimits', value), /** Produce `Numeric` enum variant */ Numeric: (value: Numeric): ParameterValueBox => lib.variant('Numeric', value), [lib.symbolCodec]: lib.enumCodec<ParameterValueBox>([[0, 'TransactionLimits', lib.toCodec(() => TransactionLimits)], [1, 'MetadataLimits', lib.toCodec(() => Limits)], [2, 'LengthLimits', lib.toCodec(() => LengthLimits)], [3, 'Numeric', lib.toCodec(() => Numeric)]]) }
export type Peer = { id: PeerId; }
export const Peer = lib.wrapCodec<Peer>(lib.structCodec([['id', lib.toCodec(() => PeerId)]]))
export type PeerEvent = lib.Enumerate<{ Added: [PeerId], Removed: [PeerId] }>
export const PeerEvent = { /** Produce `Added` enum variant */ Added: (value: PeerId): PeerEvent => lib.variant('Added', value), /** Produce `Removed` enum variant */ Removed: (value: PeerId): PeerEvent => lib.variant('Removed', value), [lib.symbolCodec]: lib.enumCodec<PeerEvent>([[0, 'Added', lib.toCodec(() => PeerId)], [1, 'Removed', lib.toCodec(() => PeerId)]]) }
export type PeerEventFilter = { idMatcher: lib.codecs.Option<PeerId>; eventSet: PeerEventSet; }
export const PeerEventFilter = lib.wrapCodec<PeerEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => PeerId))], ['eventSet', lib.toCodec(() => PeerEventSet)]]))
export type PeerEventSet = lib.codecs.U32
export const PeerEventSet = { /** `Added` event bitmask. Use `|` to combine with other {@link PeerEventSet} bitmasks. */ Added: 1, /** `Removed` event bitmask. Use `|` to combine with other {@link PeerEventSet} bitmasks. */ Removed: 2, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type PeerId = { address: SocketAddr; publicKey: PublicKey; }
export const PeerId = lib.wrapCodec<PeerId>(lib.structCodec([['address', lib.toCodec(() => SocketAddr)], ['publicKey', lib.toCodec(() => PublicKey)]]))
export type Permission = { id: PermissionId; payload: lib.codecs.Json; }
export const Permission = lib.wrapCodec<Permission>(lib.structCodec([['id', lib.toCodec(() => PermissionId)], ['payload', lib.toCodec(lib.codecs.Json)]]))
export type PermissionId = { name: lib.codecs.String; }
export const PermissionId = lib.wrapCodec<PermissionId>(lib.structCodec([['name', lib.toCodec(lib.codecs.String)]]))
export type PipelineEventBox = lib.Enumerate<{ Transaction: [TransactionEvent], Block: [BlockEvent] }>
export const PipelineEventBox = { /** Produce `Transaction` enum variant */ Transaction: (value: TransactionEvent): PipelineEventBox => lib.variant('Transaction', value), /** Produce `Block` enum variant */ Block: (value: BlockEvent): PipelineEventBox => lib.variant('Block', value), [lib.symbolCodec]: lib.enumCodec<PipelineEventBox>([[0, 'Transaction', lib.toCodec(() => TransactionEvent)], [1, 'Block', lib.toCodec(() => BlockEvent)]]) }
export type PipelineEventFilterBox = lib.Enumerate<{ Transaction: [TransactionEventFilter], Block: [BlockEventFilter] }>
export const PipelineEventFilterBox = { /** Produce `Transaction` enum variant */ Transaction: (value: TransactionEventFilter): PipelineEventFilterBox => lib.variant('Transaction', value), /** Produce `Block` enum variant */ Block: (value: BlockEventFilter): PipelineEventFilterBox => lib.variant('Block', value), [lib.symbolCodec]: lib.enumCodec<PipelineEventFilterBox>([[0, 'Transaction', lib.toCodec(() => TransactionEventFilter)], [1, 'Block', lib.toCodec(() => BlockEventFilter)]]) }
export type PredicateBox = { enum: lib.Enumerate<{ And: [NonTrivial], Or: [NonTrivial], Not: [PredicateBox], Raw: [QueryOutputPredicate] }> }
export const PredicateBox: lib.EnumBoxValue<PredicateBox> = { /** Produce `And` enum variant */ And: (value: NonTrivial): PredicateBox => ({ enum: lib.variant('And', value) }), /** Produce `Or` enum variant */ Or: (value: NonTrivial): PredicateBox => ({ enum: lib.variant('Or', value) }), /** Produce `Not` enum variant */ Not: (value: PredicateBox): PredicateBox => ({ enum: lib.variant('Not', value) }), /** Produce `Raw` enum variant */ Raw: (value: QueryOutputPredicate): PredicateBox => ({ enum: lib.variant('Raw', value) }), [lib.symbolCodec]: lib.boxEnumCodec(lib.enumCodec<PredicateBox['enum']>([[0, 'And', lib.toCodec(() => NonTrivial)], [1, 'Or', lib.toCodec(() => NonTrivial)], [2, 'Not', lib.toCodec(() => PredicateBox)], [3, 'Raw', lib.toCodec(() => QueryOutputPredicate)]])) }
export type PublicKey = { algorithm: Algorithm; payload: lib.codecs.BytesVec; }
export const PublicKey = lib.wrapCodec<PublicKey>(lib.structCodec([['algorithm', lib.toCodec(() => Algorithm)], ['payload', lib.toCodec(lib.codecs.BytesVec)]]))
export type QueryBox = lib.Enumerate<{ FindAllAccounts: [], FindAccountById: [FindAccountById], FindAccountKeyValueByIdAndKey: [FindAccountKeyValueByIdAndKey], FindAccountsByDomainId: [FindAccountsByDomainId], FindAccountsWithAsset: [FindAccountsWithAsset], FindAllAssets: [], FindAllAssetsDefinitions: [], FindAssetById: [FindAssetById], FindAssetDefinitionById: [FindAssetDefinitionById], FindAssetsByName: [FindAssetsByName], FindAssetsByAccountId: [FindAssetsByAccountId], FindAssetsByAssetDefinitionId: [FindAssetsByAssetDefinitionId], FindAssetsByDomainId: [FindAssetsByDomainId], FindAssetsByDomainIdAndAssetDefinitionId: [FindAssetsByDomainIdAndAssetDefinitionId], FindAssetQuantityById: [FindAssetQuantityById], FindTotalAssetQuantityByAssetDefinitionId: [FindTotalAssetQuantityByAssetDefinitionId], FindAssetKeyValueByIdAndKey: [FindAssetKeyValueByIdAndKey], FindAssetDefinitionKeyValueByIdAndKey: [FindAssetDefinitionKeyValueByIdAndKey], FindAllDomains: [], FindDomainById: [FindDomainById], FindDomainKeyValueByIdAndKey: [FindDomainKeyValueByIdAndKey], FindAllPeers: [], FindAllBlocks: [], FindAllBlockHeaders: [], FindBlockHeaderByHash: [FindBlockHeaderByHash], FindAllTransactions: [], FindTransactionsByAccountId: [FindTransactionsByAccountId], FindTransactionByHash: [FindTransactionByHash], FindPermissionsByAccountId: [FindPermissionsByAccountId], FindExecutorDataModel: [], FindAllActiveTriggerIds: [], FindTriggerById: [FindTriggerById], FindTriggerKeyValueByIdAndKey: [FindTriggerKeyValueByIdAndKey], FindTriggersByAuthorityId: [FindTriggersByAuthorityId], FindTriggersByAuthorityDomainId: [FindTriggersByAuthorityDomainId], FindAllRoles: [], FindAllRoleIds: [], FindRoleByRoleId: [FindRoleByRoleId], FindRolesByAccountId: [FindRolesByAccountId], FindAllParameters: [] }>
export const QueryBox = { /** `FindAllAccounts` enum variant */ FindAllAccounts: lib.variant<QueryBox>('FindAllAccounts'), /** Produce `FindAccountById` enum variant */ FindAccountById: (value: FindAccountById): QueryBox => lib.variant('FindAccountById', value), /** Produce `FindAccountKeyValueByIdAndKey` enum variant */ FindAccountKeyValueByIdAndKey: (value: FindAccountKeyValueByIdAndKey): QueryBox => lib.variant('FindAccountKeyValueByIdAndKey', value), /** Produce `FindAccountsByDomainId` enum variant */ FindAccountsByDomainId: (value: FindAccountsByDomainId): QueryBox => lib.variant('FindAccountsByDomainId', value), /** Produce `FindAccountsWithAsset` enum variant */ FindAccountsWithAsset: (value: FindAccountsWithAsset): QueryBox => lib.variant('FindAccountsWithAsset', value), /** `FindAllAssets` enum variant */ FindAllAssets: lib.variant<QueryBox>('FindAllAssets'), /** `FindAllAssetsDefinitions` enum variant */ FindAllAssetsDefinitions: lib.variant<QueryBox>('FindAllAssetsDefinitions'), /** Produce `FindAssetById` enum variant */ FindAssetById: (value: FindAssetById): QueryBox => lib.variant('FindAssetById', value), /** Produce `FindAssetDefinitionById` enum variant */ FindAssetDefinitionById: (value: FindAssetDefinitionById): QueryBox => lib.variant('FindAssetDefinitionById', value), /** Produce `FindAssetsByName` enum variant */ FindAssetsByName: (value: FindAssetsByName): QueryBox => lib.variant('FindAssetsByName', value), /** Produce `FindAssetsByAccountId` enum variant */ FindAssetsByAccountId: (value: FindAssetsByAccountId): QueryBox => lib.variant('FindAssetsByAccountId', value), /** Produce `FindAssetsByAssetDefinitionId` enum variant */ FindAssetsByAssetDefinitionId: (value: FindAssetsByAssetDefinitionId): QueryBox => lib.variant('FindAssetsByAssetDefinitionId', value), /** Produce `FindAssetsByDomainId` enum variant */ FindAssetsByDomainId: (value: FindAssetsByDomainId): QueryBox => lib.variant('FindAssetsByDomainId', value), /** Produce `FindAssetsByDomainIdAndAssetDefinitionId` enum variant */ FindAssetsByDomainIdAndAssetDefinitionId: (value: FindAssetsByDomainIdAndAssetDefinitionId): QueryBox => lib.variant('FindAssetsByDomainIdAndAssetDefinitionId', value), /** Produce `FindAssetQuantityById` enum variant */ FindAssetQuantityById: (value: FindAssetQuantityById): QueryBox => lib.variant('FindAssetQuantityById', value), /** Produce `FindTotalAssetQuantityByAssetDefinitionId` enum variant */ FindTotalAssetQuantityByAssetDefinitionId: (value: FindTotalAssetQuantityByAssetDefinitionId): QueryBox => lib.variant('FindTotalAssetQuantityByAssetDefinitionId', value), /** Produce `FindAssetKeyValueByIdAndKey` enum variant */ FindAssetKeyValueByIdAndKey: (value: FindAssetKeyValueByIdAndKey): QueryBox => lib.variant('FindAssetKeyValueByIdAndKey', value), /** Produce `FindAssetDefinitionKeyValueByIdAndKey` enum variant */ FindAssetDefinitionKeyValueByIdAndKey: (value: FindAssetDefinitionKeyValueByIdAndKey): QueryBox => lib.variant('FindAssetDefinitionKeyValueByIdAndKey', value), /** `FindAllDomains` enum variant */ FindAllDomains: lib.variant<QueryBox>('FindAllDomains'), /** Produce `FindDomainById` enum variant */ FindDomainById: (value: FindDomainById): QueryBox => lib.variant('FindDomainById', value), /** Produce `FindDomainKeyValueByIdAndKey` enum variant */ FindDomainKeyValueByIdAndKey: (value: FindDomainKeyValueByIdAndKey): QueryBox => lib.variant('FindDomainKeyValueByIdAndKey', value), /** `FindAllPeers` enum variant */ FindAllPeers: lib.variant<QueryBox>('FindAllPeers'), /** `FindAllBlocks` enum variant */ FindAllBlocks: lib.variant<QueryBox>('FindAllBlocks'), /** `FindAllBlockHeaders` enum variant */ FindAllBlockHeaders: lib.variant<QueryBox>('FindAllBlockHeaders'), /** Produce `FindBlockHeaderByHash` enum variant */ FindBlockHeaderByHash: (value: FindBlockHeaderByHash): QueryBox => lib.variant('FindBlockHeaderByHash', value), /** `FindAllTransactions` enum variant */ FindAllTransactions: lib.variant<QueryBox>('FindAllTransactions'), /** Produce `FindTransactionsByAccountId` enum variant */ FindTransactionsByAccountId: (value: FindTransactionsByAccountId): QueryBox => lib.variant('FindTransactionsByAccountId', value), /** Produce `FindTransactionByHash` enum variant */ FindTransactionByHash: (value: FindTransactionByHash): QueryBox => lib.variant('FindTransactionByHash', value), /** Produce `FindPermissionsByAccountId` enum variant */ FindPermissionsByAccountId: (value: FindPermissionsByAccountId): QueryBox => lib.variant('FindPermissionsByAccountId', value), /** `FindExecutorDataModel` enum variant */ FindExecutorDataModel: lib.variant<QueryBox>('FindExecutorDataModel'), /** `FindAllActiveTriggerIds` enum variant */ FindAllActiveTriggerIds: lib.variant<QueryBox>('FindAllActiveTriggerIds'), /** Produce `FindTriggerById` enum variant */ FindTriggerById: (value: FindTriggerById): QueryBox => lib.variant('FindTriggerById', value), /** Produce `FindTriggerKeyValueByIdAndKey` enum variant */ FindTriggerKeyValueByIdAndKey: (value: FindTriggerKeyValueByIdAndKey): QueryBox => lib.variant('FindTriggerKeyValueByIdAndKey', value), /** Produce `FindTriggersByAuthorityId` enum variant */ FindTriggersByAuthorityId: (value: FindTriggersByAuthorityId): QueryBox => lib.variant('FindTriggersByAuthorityId', value), /** Produce `FindTriggersByAuthorityDomainId` enum variant */ FindTriggersByAuthorityDomainId: (value: FindTriggersByAuthorityDomainId): QueryBox => lib.variant('FindTriggersByAuthorityDomainId', value), /** `FindAllRoles` enum variant */ FindAllRoles: lib.variant<QueryBox>('FindAllRoles'), /** `FindAllRoleIds` enum variant */ FindAllRoleIds: lib.variant<QueryBox>('FindAllRoleIds'), /** Produce `FindRoleByRoleId` enum variant */ FindRoleByRoleId: (value: FindRoleByRoleId): QueryBox => lib.variant('FindRoleByRoleId', value), /** Produce `FindRolesByAccountId` enum variant */ FindRolesByAccountId: (value: FindRolesByAccountId): QueryBox => lib.variant('FindRolesByAccountId', value), /** `FindAllParameters` enum variant */ FindAllParameters: lib.variant<QueryBox>('FindAllParameters'), [lib.symbolCodec]: lib.enumCodec<QueryBox>([[0, 'FindAllAccounts'], [1, 'FindAccountById', lib.toCodec(() => FindAccountById)], [2, 'FindAccountKeyValueByIdAndKey', lib.toCodec(() => FindAccountKeyValueByIdAndKey)], [3, 'FindAccountsByDomainId', lib.toCodec(() => FindAccountsByDomainId)], [4, 'FindAccountsWithAsset', lib.toCodec(() => FindAccountsWithAsset)], [5, 'FindAllAssets'], [6, 'FindAllAssetsDefinitions'], [7, 'FindAssetById', lib.toCodec(() => FindAssetById)], [8, 'FindAssetDefinitionById', lib.toCodec(() => FindAssetDefinitionById)], [9, 'FindAssetsByName', lib.toCodec(() => FindAssetsByName)], [10, 'FindAssetsByAccountId', lib.toCodec(() => FindAssetsByAccountId)], [11, 'FindAssetsByAssetDefinitionId', lib.toCodec(() => FindAssetsByAssetDefinitionId)], [12, 'FindAssetsByDomainId', lib.toCodec(() => FindAssetsByDomainId)], [13, 'FindAssetsByDomainIdAndAssetDefinitionId', lib.toCodec(() => FindAssetsByDomainIdAndAssetDefinitionId)], [14, 'FindAssetQuantityById', lib.toCodec(() => FindAssetQuantityById)], [15, 'FindTotalAssetQuantityByAssetDefinitionId', lib.toCodec(() => FindTotalAssetQuantityByAssetDefinitionId)], [16, 'FindAssetKeyValueByIdAndKey', lib.toCodec(() => FindAssetKeyValueByIdAndKey)], [17, 'FindAssetDefinitionKeyValueByIdAndKey', lib.toCodec(() => FindAssetDefinitionKeyValueByIdAndKey)], [18, 'FindAllDomains'], [19, 'FindDomainById', lib.toCodec(() => FindDomainById)], [20, 'FindDomainKeyValueByIdAndKey', lib.toCodec(() => FindDomainKeyValueByIdAndKey)], [21, 'FindAllPeers'], [22, 'FindAllBlocks'], [23, 'FindAllBlockHeaders'], [24, 'FindBlockHeaderByHash', lib.toCodec(() => FindBlockHeaderByHash)], [25, 'FindAllTransactions'], [26, 'FindTransactionsByAccountId', lib.toCodec(() => FindTransactionsByAccountId)], [27, 'FindTransactionByHash', lib.toCodec(() => FindTransactionByHash)], [28, 'FindPermissionsByAccountId', lib.toCodec(() => FindPermissionsByAccountId)], [29, 'FindExecutorDataModel'], [30, 'FindAllActiveTriggerIds'], [31, 'FindTriggerById', lib.toCodec(() => FindTriggerById)], [32, 'FindTriggerKeyValueByIdAndKey', lib.toCodec(() => FindTriggerKeyValueByIdAndKey)], [33, 'FindTriggersByAuthorityId', lib.toCodec(() => FindTriggersByAuthorityId)], [34, 'FindTriggersByAuthorityDomainId', lib.toCodec(() => FindTriggersByAuthorityDomainId)], [35, 'FindAllRoles'], [36, 'FindAllRoleIds'], [37, 'FindRoleByRoleId', lib.toCodec(() => FindRoleByRoleId)], [38, 'FindRolesByAccountId', lib.toCodec(() => FindRolesByAccountId)], [39, 'FindAllParameters']]) }
export type QueryExecutionFail = lib.Enumerate<{ Find: [FindError], Conversion: [lib.codecs.String], UnknownCursor: [], FetchSizeTooBig: [], InvalidSingularParameters: [] }>
export const QueryExecutionFail = { /** Produce `Find` enum variant */ Find: (value: FindError): QueryExecutionFail => lib.variant('Find', value), /** Produce `Conversion` enum variant */ Conversion: (value: lib.codecs.String): QueryExecutionFail => lib.variant('Conversion', value), /** `UnknownCursor` enum variant */ UnknownCursor: lib.variant<QueryExecutionFail>('UnknownCursor'), /** `FetchSizeTooBig` enum variant */ FetchSizeTooBig: lib.variant<QueryExecutionFail>('FetchSizeTooBig'), /** `InvalidSingularParameters` enum variant */ InvalidSingularParameters: lib.variant<QueryExecutionFail>('InvalidSingularParameters'), [lib.symbolCodec]: lib.enumCodec<QueryExecutionFail>([[0, 'Find', lib.toCodec(() => FindError)], [1, 'Conversion', lib.toCodec(lib.codecs.String)], [2, 'UnknownCursor'], [3, 'FetchSizeTooBig'], [4, 'InvalidSingularParameters']]) }
export type QueryOutputBox = { enum: lib.Enumerate<{ Id: [IdBox], Identifiable: [IdentifiableBox], Transaction: [TransactionQueryOutput], Permission: [Permission], LimitedMetadata: [MetadataValueBox], Numeric: [Numeric], BlockHeader: [BlockHeader], Block: [SignedBlock], ExecutorDataModel: [ExecutorDataModel], Vec: [lib.codecs.Vec<QueryOutputBox>] }> }
export const QueryOutputBox: lib.EnumBoxValue<QueryOutputBox> = { /** Produce `Id` enum variant */ Id: (value: IdBox): QueryOutputBox => ({ enum: lib.variant('Id', value) }), /** Produce `Identifiable` enum variant */ Identifiable: (value: IdentifiableBox): QueryOutputBox => ({ enum: lib.variant('Identifiable', value) }), /** Produce `Transaction` enum variant */ Transaction: (value: TransactionQueryOutput): QueryOutputBox => ({ enum: lib.variant('Transaction', value) }), /** Produce `Permission` enum variant */ Permission: (value: Permission): QueryOutputBox => ({ enum: lib.variant('Permission', value) }), /** Produce `LimitedMetadata` enum variant */ LimitedMetadata: (value: MetadataValueBox): QueryOutputBox => ({ enum: lib.variant('LimitedMetadata', value) }), /** Produce `Numeric` enum variant */ Numeric: (value: Numeric): QueryOutputBox => ({ enum: lib.variant('Numeric', value) }), /** Produce `BlockHeader` enum variant */ BlockHeader: (value: BlockHeader): QueryOutputBox => ({ enum: lib.variant('BlockHeader', value) }), /** Produce `Block` enum variant */ Block: (value: SignedBlock): QueryOutputBox => ({ enum: lib.variant('Block', value) }), /** Produce `ExecutorDataModel` enum variant */ ExecutorDataModel: (value: ExecutorDataModel): QueryOutputBox => ({ enum: lib.variant('ExecutorDataModel', value) }), /** Produce `Vec` enum variant */ Vec: (value: lib.codecs.Vec<QueryOutputBox>): QueryOutputBox => ({ enum: lib.variant('Vec', value) }), [lib.symbolCodec]: lib.boxEnumCodec(lib.enumCodec<QueryOutputBox['enum']>([[0, 'Id', lib.toCodec(() => IdBox)], [1, 'Identifiable', lib.toCodec(() => IdentifiableBox)], [2, 'Transaction', lib.toCodec(() => TransactionQueryOutput)], [3, 'Permission', lib.toCodec(() => Permission)], [4, 'LimitedMetadata', lib.toCodec(() => MetadataValueBox)], [5, 'Numeric', lib.toCodec(() => Numeric)], [6, 'BlockHeader', lib.toCodec(() => BlockHeader)], [7, 'Block', lib.toCodec(() => SignedBlock)], [8, 'ExecutorDataModel', lib.toCodec(() => ExecutorDataModel)], [9, 'Vec', lib.codecs.Vec.with(lib.toCodec(() => QueryOutputBox))]])) }
export type QueryOutputPredicate = { enum: lib.Enumerate<{ Identifiable: [StringPredicate], Container: [Container], Display: [StringPredicate], Numerical: [SemiRange], TimeStamp: [SemiInterval<lib.codecs.U128>], Pass: [] }> }
export const QueryOutputPredicate: lib.EnumBoxValue<QueryOutputPredicate> = { /** Produce `Identifiable` enum variant */ Identifiable: (value: StringPredicate): QueryOutputPredicate => ({ enum: lib.variant('Identifiable', value) }), /** Produce `Container` enum variant */ Container: (value: Container): QueryOutputPredicate => ({ enum: lib.variant('Container', value) }), /** Produce `Display` enum variant */ Display: (value: StringPredicate): QueryOutputPredicate => ({ enum: lib.variant('Display', value) }), /** Produce `Numerical` enum variant */ Numerical: (value: SemiRange): QueryOutputPredicate => ({ enum: lib.variant('Numerical', value) }), /** Produce `TimeStamp` enum variant */ TimeStamp: (value: SemiInterval<lib.codecs.U128>): QueryOutputPredicate => ({ enum: lib.variant('TimeStamp', value) }), /** `Pass` enum variant */ Pass: { enum: lib.variant<QueryOutputPredicate['enum']>('Pass') }, [lib.symbolCodec]: lib.boxEnumCodec(lib.enumCodec<QueryOutputPredicate['enum']>([[0, 'Identifiable', lib.toCodec(() => StringPredicate)], [1, 'Container', lib.toCodec(() => Container)], [2, 'Display', lib.toCodec(() => StringPredicate)], [3, 'Numerical', lib.toCodec(() => SemiRange)], [4, 'TimeStamp', lib.toCodec(() => SemiInterval.with(lib.toCodec(lib.codecs.U128)))], [5, 'Pass']])) }
export type Register<T0> = { object: T0 }
export const Register = { with: <T0>(codec0: lib.Codec<T0>): lib.Codec<Register<T0>> => { return lib.structCodec([['object', codec0]]) } }
export type RegisterBox = lib.Enumerate<{ Peer: [Register<Peer>], Domain: [Register<NewDomain>], Account: [Register<NewAccount>], AssetDefinition: [Register<NewAssetDefinition>], Asset: [Register<Asset>], Role: [Register<NewRole>], Trigger: [Register<Trigger>] }>
export const RegisterBox = { /** Produce `Peer` enum variant */ Peer: (value: Register<Peer>): RegisterBox => lib.variant('Peer', value), /** Produce `Domain` enum variant */ Domain: (value: Register<NewDomain>): RegisterBox => lib.variant('Domain', value), /** Produce `Account` enum variant */ Account: (value: Register<NewAccount>): RegisterBox => lib.variant('Account', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: Register<NewAssetDefinition>): RegisterBox => lib.variant('AssetDefinition', value), /** Produce `Asset` enum variant */ Asset: (value: Register<Asset>): RegisterBox => lib.variant('Asset', value), /** Produce `Role` enum variant */ Role: (value: Register<NewRole>): RegisterBox => lib.variant('Role', value), /** Produce `Trigger` enum variant */ Trigger: (value: Register<Trigger>): RegisterBox => lib.variant('Trigger', value), [lib.symbolCodec]: lib.enumCodec<RegisterBox>([[0, 'Peer', lib.toCodec(() => Register.with(lib.toCodec(() => Peer)))], [1, 'Domain', lib.toCodec(() => Register.with(lib.toCodec(() => NewDomain)))], [2, 'Account', lib.toCodec(() => Register.with(lib.toCodec(() => NewAccount)))], [3, 'AssetDefinition', lib.toCodec(() => Register.with(lib.toCodec(() => NewAssetDefinition)))], [4, 'Asset', lib.toCodec(() => Register.with(lib.toCodec(() => Asset)))], [5, 'Role', lib.toCodec(() => Register.with(lib.toCodec(() => NewRole)))], [6, 'Trigger', lib.toCodec(() => Register.with(lib.toCodec(() => Trigger)))]]) }
export type RemoveKeyValue<T0> = { object: T0, key: lib.codecs.String, value: MetadataValueBox }
export const RemoveKeyValue = { with: <T0>(codec0: lib.Codec<T0>): lib.Codec<RemoveKeyValue<T0>> => { return lib.structCodec([['object', codec0], ['key', lib.toCodec(lib.codecs.String)], ['value', lib.toCodec(() => MetadataValueBox)]]) } }
export type RemoveKeyValueBox = lib.Enumerate<{ Domain: [RemoveKeyValue<Domain>], Account: [RemoveKeyValue<Account>], AssetDefinition: [RemoveKeyValue<AssetDefinition>], Asset: [RemoveKeyValue<Asset>], Trigger: [RemoveKeyValue<Trigger>] }>
export const RemoveKeyValueBox = { /** Produce `Domain` enum variant */ Domain: (value: RemoveKeyValue<Domain>): RemoveKeyValueBox => lib.variant('Domain', value), /** Produce `Account` enum variant */ Account: (value: RemoveKeyValue<Account>): RemoveKeyValueBox => lib.variant('Account', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: RemoveKeyValue<AssetDefinition>): RemoveKeyValueBox => lib.variant('AssetDefinition', value), /** Produce `Asset` enum variant */ Asset: (value: RemoveKeyValue<Asset>): RemoveKeyValueBox => lib.variant('Asset', value), /** Produce `Trigger` enum variant */ Trigger: (value: RemoveKeyValue<Trigger>): RemoveKeyValueBox => lib.variant('Trigger', value), [lib.symbolCodec]: lib.enumCodec<RemoveKeyValueBox>([[0, 'Domain', lib.toCodec(() => RemoveKeyValue.with(lib.toCodec(() => Domain)))], [1, 'Account', lib.toCodec(() => RemoveKeyValue.with(lib.toCodec(() => Account)))], [2, 'AssetDefinition', lib.toCodec(() => RemoveKeyValue.with(lib.toCodec(() => AssetDefinition)))], [3, 'Asset', lib.toCodec(() => RemoveKeyValue.with(lib.toCodec(() => Asset)))], [4, 'Trigger', lib.toCodec(() => RemoveKeyValue.with(lib.toCodec(() => Trigger)))]]) }
export type Repeats = lib.Enumerate<{ Indefinitely: [], Exactly: [lib.codecs.U32] }>
export const Repeats = { /** `Indefinitely` enum variant */ Indefinitely: lib.variant<Repeats>('Indefinitely'), /** Produce `Exactly` enum variant */ Exactly: (value: lib.codecs.U32): Repeats => lib.variant('Exactly', value), [lib.symbolCodec]: lib.enumCodec<Repeats>([[0, 'Indefinitely'], [1, 'Exactly', lib.toCodec(lib.codecs.U32)]]) }
export type RepetitionError = { instructionType: InstructionType; id: IdBox; }
export const RepetitionError = lib.wrapCodec<RepetitionError>(lib.structCodec([['instructionType', lib.toCodec(() => InstructionType)], ['id', lib.toCodec(() => IdBox)]]))
export type Revoke<T0, T1> = { object: T0, destination: T1 }
export const Revoke = { with: <T0, T1>(codec0: lib.Codec<T0>,codec1: lib.Codec<T1>): lib.Codec<Revoke<T0, T1>> => { return lib.structCodec([['object', codec0], ['destination', codec1]]) } }
export type RevokeBox = lib.Enumerate<{ Permission: [Revoke<Permission, AccountId>], Role: [Revoke<RoleId, AccountId>], RolePermission: [Revoke<Permission, RoleId>] }>
export const RevokeBox = { /** Produce `Permission` enum variant */ Permission: (value: Revoke<Permission, AccountId>): RevokeBox => lib.variant('Permission', value), /** Produce `Role` enum variant */ Role: (value: Revoke<RoleId, AccountId>): RevokeBox => lib.variant('Role', value), /** Produce `RolePermission` enum variant */ RolePermission: (value: Revoke<Permission, RoleId>): RevokeBox => lib.variant('RolePermission', value), [lib.symbolCodec]: lib.enumCodec<RevokeBox>([[0, 'Permission', lib.toCodec(() => Revoke.with(lib.toCodec(() => Permission), lib.toCodec(() => AccountId)))], [1, 'Role', lib.toCodec(() => Revoke.with(lib.toCodec(() => RoleId), lib.toCodec(() => AccountId)))], [2, 'RolePermission', lib.toCodec(() => Revoke.with(lib.toCodec(() => Permission), lib.toCodec(() => RoleId)))]]) }
export type Role = { id: RoleId; permissions: lib.codecs.Vec<Permission>; }
export const Role = lib.wrapCodec<Role>(lib.structCodec([['id', lib.toCodec(() => RoleId)], ['permissions', lib.codecs.Vec.with(lib.toCodec(() => Permission))]]))
export type RoleEvent = lib.Enumerate<{ Created: [Role], Deleted: [RoleId], PermissionRemoved: [RolePermissionChanged], PermissionAdded: [RolePermissionChanged] }>
export const RoleEvent = { /** Produce `Created` enum variant */ Created: (value: Role): RoleEvent => lib.variant('Created', value), /** Produce `Deleted` enum variant */ Deleted: (value: RoleId): RoleEvent => lib.variant('Deleted', value), /** Produce `PermissionRemoved` enum variant */ PermissionRemoved: (value: RolePermissionChanged): RoleEvent => lib.variant('PermissionRemoved', value), /** Produce `PermissionAdded` enum variant */ PermissionAdded: (value: RolePermissionChanged): RoleEvent => lib.variant('PermissionAdded', value), [lib.symbolCodec]: lib.enumCodec<RoleEvent>([[0, 'Created', lib.toCodec(() => Role)], [1, 'Deleted', lib.toCodec(() => RoleId)], [2, 'PermissionRemoved', lib.toCodec(() => RolePermissionChanged)], [3, 'PermissionAdded', lib.toCodec(() => RolePermissionChanged)]]) }
export type RoleEventFilter = { idMatcher: lib.codecs.Option<RoleId>; eventSet: RoleEventSet; }
export const RoleEventFilter = lib.wrapCodec<RoleEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => RoleId))], ['eventSet', lib.toCodec(() => RoleEventSet)]]))
export type RoleEventSet = lib.codecs.U32
export const RoleEventSet = { /** `Created` event bitmask. Use `|` to combine with other {@link RoleEventSet} bitmasks. */ Created: 1, /** `Deleted` event bitmask. Use `|` to combine with other {@link RoleEventSet} bitmasks. */ Deleted: 2, /** `PermissionRemoved` event bitmask. Use `|` to combine with other {@link RoleEventSet} bitmasks. */ PermissionRemoved: 4, /** `PermissionAdded` event bitmask. Use `|` to combine with other {@link RoleEventSet} bitmasks. */ PermissionAdded: 8, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type RoleId = { name: lib.codecs.String; }
export const RoleId = lib.wrapCodec<RoleId>(lib.structCodec([['name', lib.toCodec(lib.codecs.String)]]))
export type RolePermissionChanged = { role: RoleId; permission: PermissionId; }
export const RolePermissionChanged = lib.wrapCodec<RolePermissionChanged>(lib.structCodec([['role', lib.toCodec(() => RoleId)], ['permission', lib.toCodec(() => PermissionId)]]))
export type Schedule = { start: Duration; period: lib.codecs.Option<Duration>; }
export const Schedule = lib.wrapCodec<Schedule>(lib.structCodec([['start', lib.toCodec(() => Duration)], ['period', lib.codecs.Option.with(lib.toCodec(() => Duration))]]))
export type SemiInterval<T0> = { start: T0, limit: T0 }
export const SemiInterval = { with: <T0>(codec0: lib.Codec<T0>): lib.Codec<SemiInterval<T0>> => { return lib.structCodec([['start', codec0], ['limit', codec0]]) } }
export type SemiRange = lib.Enumerate<{ Numeric: [SemiInterval<Numeric>] }>
export const SemiRange = { /** Produce `Numeric` enum variant */ Numeric: (value: SemiInterval<Numeric>): SemiRange => lib.variant('Numeric', value), [lib.symbolCodec]: lib.enumCodec<SemiRange>([[0, 'Numeric', lib.toCodec(() => SemiInterval.with(lib.toCodec(() => Numeric)))]]) }
export type SetKeyValue<T0> = { object: T0, key: lib.codecs.String, value: MetadataValueBox }
export const SetKeyValue = { with: <T0>(codec0: lib.Codec<T0>): lib.Codec<SetKeyValue<T0>> => { return lib.structCodec([['object', codec0], ['key', lib.toCodec(lib.codecs.String)], ['value', lib.toCodec(() => MetadataValueBox)]]) } }
export type SetKeyValueBox = lib.Enumerate<{ Domain: [SetKeyValue<Domain>], Account: [SetKeyValue<Account>], AssetDefinition: [SetKeyValue<AssetDefinition>], Asset: [SetKeyValue<Asset>], Trigger: [SetKeyValue<Trigger>] }>
export const SetKeyValueBox = { /** Produce `Domain` enum variant */ Domain: (value: SetKeyValue<Domain>): SetKeyValueBox => lib.variant('Domain', value), /** Produce `Account` enum variant */ Account: (value: SetKeyValue<Account>): SetKeyValueBox => lib.variant('Account', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: SetKeyValue<AssetDefinition>): SetKeyValueBox => lib.variant('AssetDefinition', value), /** Produce `Asset` enum variant */ Asset: (value: SetKeyValue<Asset>): SetKeyValueBox => lib.variant('Asset', value), /** Produce `Trigger` enum variant */ Trigger: (value: SetKeyValue<Trigger>): SetKeyValueBox => lib.variant('Trigger', value), [lib.symbolCodec]: lib.enumCodec<SetKeyValueBox>([[0, 'Domain', lib.toCodec(() => SetKeyValue.with(lib.toCodec(() => Domain)))], [1, 'Account', lib.toCodec(() => SetKeyValue.with(lib.toCodec(() => Account)))], [2, 'AssetDefinition', lib.toCodec(() => SetKeyValue.with(lib.toCodec(() => AssetDefinition)))], [3, 'Asset', lib.toCodec(() => SetKeyValue.with(lib.toCodec(() => Asset)))], [4, 'Trigger', lib.toCodec(() => SetKeyValue.with(lib.toCodec(() => Trigger)))]]) }
export type SetParameter = { parameter: Parameter; }
export const SetParameter = lib.wrapCodec<SetParameter>(lib.structCodec([['parameter', lib.toCodec(() => Parameter)]]))
export type Signature = { payload: lib.codecs.BytesVec; }
export const Signature = lib.wrapCodec<Signature>(lib.structCodec([['payload', lib.toCodec(lib.codecs.BytesVec)]]))
export type SignedBlock = lib.Enumerate<{ V1: [SignedBlockV1] }>
export const SignedBlock = { /** Produce `V1` enum variant */ V1: (value: SignedBlockV1): SignedBlock => lib.variant('V1', value), [lib.symbolCodec]: lib.enumCodec<SignedBlock>([[1, 'V1', lib.toCodec(() => SignedBlockV1)]]) }
export type SignedBlockV1 = { signatures: lib.codecs.Vec<BlockSignature>; payload: BlockPayload; }
export const SignedBlockV1 = lib.wrapCodec<SignedBlockV1>(lib.structCodec([['signatures', lib.codecs.Vec.with(lib.toCodec(() => BlockSignature))], ['payload', lib.toCodec(() => BlockPayload)]]))
export type SignedQuery = lib.Enumerate<{ V1: [SignedQueryV1] }>
export const SignedQuery = { /** Produce `V1` enum variant */ V1: (value: SignedQueryV1): SignedQuery => lib.variant('V1', value), [lib.symbolCodec]: lib.enumCodec<SignedQuery>([[1, 'V1', lib.toCodec(() => SignedQueryV1)]]) }
export type SignedQueryV1 = { signature: Signature; payload: ClientQueryPayload; }
export const SignedQueryV1 = lib.wrapCodec<SignedQueryV1>(lib.structCodec([['signature', lib.toCodec(() => Signature)], ['payload', lib.toCodec(() => ClientQueryPayload)]]))
export type SignedTransaction = lib.Enumerate<{ V1: [SignedTransactionV1] }>
export const SignedTransaction = { /** Produce `V1` enum variant */ V1: (value: SignedTransactionV1): SignedTransaction => lib.variant('V1', value), [lib.symbolCodec]: lib.enumCodec<SignedTransaction>([[1, 'V1', lib.toCodec(() => SignedTransactionV1)]]) }
export type SignedTransactionV1 = { signature: Signature; payload: TransactionPayload; }
export const SignedTransactionV1 = lib.wrapCodec<SignedTransactionV1>(lib.structCodec([['signature', lib.toCodec(() => Signature)], ['payload', lib.toCodec(() => TransactionPayload)]]))
export type SizeError = { limits: Limits; actual: lib.codecs.U64; }
export const SizeError = lib.wrapCodec<SizeError>(lib.structCodec([['limits', lib.toCodec(() => Limits)], ['actual', lib.toCodec(lib.codecs.U64)]]))
export type SocketAddr = lib.Enumerate<{ Ipv4: [SocketAddrV4], Ipv6: [SocketAddrV6], Host: [SocketAddrHost] }>
export const SocketAddr = { /** Produce `Ipv4` enum variant */ Ipv4: (value: SocketAddrV4): SocketAddr => lib.variant('Ipv4', value), /** Produce `Ipv6` enum variant */ Ipv6: (value: SocketAddrV6): SocketAddr => lib.variant('Ipv6', value), /** Produce `Host` enum variant */ Host: (value: SocketAddrHost): SocketAddr => lib.variant('Host', value), [lib.symbolCodec]: lib.enumCodec<SocketAddr>([[0, 'Ipv4', lib.toCodec(() => SocketAddrV4)], [1, 'Ipv6', lib.toCodec(() => SocketAddrV6)], [2, 'Host', lib.toCodec(() => SocketAddrHost)]]) }
export type SocketAddrHost = { host: lib.codecs.String; port: lib.codecs.U16; }
export const SocketAddrHost = lib.wrapCodec<SocketAddrHost>(lib.structCodec([['host', lib.toCodec(lib.codecs.String)], ['port', lib.toCodec(lib.codecs.U16)]]))
export type SocketAddrV4 = { ip: Ipv4Addr; port: lib.codecs.U16; }
export const SocketAddrV4 = lib.wrapCodec<SocketAddrV4>(lib.structCodec([['ip', lib.toCodec(() => Ipv4Addr)], ['port', lib.toCodec(lib.codecs.U16)]]))
export type SocketAddrV6 = { ip: Ipv6Addr; port: lib.codecs.U16; }
export const SocketAddrV6 = lib.wrapCodec<SocketAddrV6>(lib.structCodec([['ip', lib.toCodec(() => Ipv6Addr)], ['port', lib.toCodec(lib.codecs.U16)]]))
export type Sorting = { sortByMetadataKey: lib.codecs.Option<lib.codecs.String>; }
export const Sorting = lib.wrapCodec<Sorting>(lib.structCodec([['sortByMetadataKey', lib.codecs.Option.with(lib.toCodec(lib.codecs.String))]]))
export type StringPredicate = lib.Enumerate<{ Contains: [lib.codecs.String], StartsWith: [lib.codecs.String], EndsWith: [lib.codecs.String], Is: [lib.codecs.String] }>
export const StringPredicate = { /** Produce `Contains` enum variant */ Contains: (value: lib.codecs.String): StringPredicate => lib.variant('Contains', value), /** Produce `StartsWith` enum variant */ StartsWith: (value: lib.codecs.String): StringPredicate => lib.variant('StartsWith', value), /** Produce `EndsWith` enum variant */ EndsWith: (value: lib.codecs.String): StringPredicate => lib.variant('EndsWith', value), /** Produce `Is` enum variant */ Is: (value: lib.codecs.String): StringPredicate => lib.variant('Is', value), [lib.symbolCodec]: lib.enumCodec<StringPredicate>([[0, 'Contains', lib.toCodec(lib.codecs.String)], [1, 'StartsWith', lib.toCodec(lib.codecs.String)], [2, 'EndsWith', lib.toCodec(lib.codecs.String)], [3, 'Is', lib.toCodec(lib.codecs.String)]]) }
export type TimeEvent = { prevInterval: lib.codecs.Option<TimeInterval>; interval: TimeInterval; }
export const TimeEvent = lib.wrapCodec<TimeEvent>(lib.structCodec([['prevInterval', lib.codecs.Option.with(lib.toCodec(() => TimeInterval))], ['interval', lib.toCodec(() => TimeInterval)]]))
export type TimeInterval = { since: Duration; length: Duration; }
export const TimeInterval = lib.wrapCodec<TimeInterval>(lib.structCodec([['since', lib.toCodec(() => Duration)], ['length', lib.toCodec(() => Duration)]]))
export type TransactionEvent = { hash: Hash; blockHeight: lib.codecs.Option<lib.codecs.U64>; status: TransactionStatus; }
export const TransactionEvent = lib.wrapCodec<TransactionEvent>(lib.structCodec([['hash', lib.toCodec(() => Hash)], ['blockHeight', lib.codecs.Option.with(lib.toCodec(lib.codecs.U64))], ['status', lib.toCodec(() => TransactionStatus)]]))
export type TransactionEventFilter = { hash: lib.codecs.Option<Hash>; blockHeight: lib.codecs.Option<lib.codecs.Option<lib.codecs.U64>>; status: lib.codecs.Option<TransactionStatus>; }
export const TransactionEventFilter = lib.wrapCodec<TransactionEventFilter>(lib.structCodec([['hash', lib.codecs.Option.with(lib.toCodec(() => Hash))], ['blockHeight', lib.codecs.Option.with(lib.codecs.Option.with(lib.toCodec(lib.codecs.U64)))], ['status', lib.codecs.Option.with(lib.toCodec(() => TransactionStatus))]]))
export type TransactionLimitError = { reason: lib.codecs.String; }
export const TransactionLimitError = lib.wrapCodec<TransactionLimitError>(lib.structCodec([['reason', lib.toCodec(lib.codecs.String)]]))
export type TransactionLimits = { maxInstructionNumber: lib.codecs.U64; maxWasmSizeBytes: lib.codecs.U64; }
export const TransactionLimits = lib.wrapCodec<TransactionLimits>(lib.structCodec([['maxInstructionNumber', lib.toCodec(lib.codecs.U64)], ['maxWasmSizeBytes', lib.toCodec(lib.codecs.U64)]]))
export type TransactionPayload = { chain: lib.codecs.String; authority: AccountId; creationTimeMs: lib.codecs.U64; instructions: Executable; timeToLiveMs: lib.codecs.Option<lib.codecs.NonZero<lib.codecs.U64>>; nonce: lib.codecs.Option<lib.codecs.NonZero<lib.codecs.U32>>; metadata: lib.codecs.Map<lib.codecs.String, MetadataValueBox>; }
export const TransactionPayload = lib.wrapCodec<TransactionPayload>(lib.structCodec([['chain', lib.toCodec(lib.codecs.String)], ['authority', lib.toCodec(() => AccountId)], ['creationTimeMs', lib.toCodec(lib.codecs.U64)], ['instructions', lib.toCodec(() => Executable)], ['timeToLiveMs', lib.codecs.Option.with(lib.codecs.NonZero.with(lib.toCodec(lib.codecs.U64)))], ['nonce', lib.codecs.Option.with(lib.codecs.NonZero.with(lib.toCodec(lib.codecs.U32)))], ['metadata', lib.codecs.Map.with(lib.toCodec(lib.codecs.String), lib.toCodec(() => MetadataValueBox))]]))
export type TransactionQueryOutput = { blockHash: Hash; transaction: CommittedTransaction; }
export const TransactionQueryOutput = lib.wrapCodec<TransactionQueryOutput>(lib.structCodec([['blockHash', lib.toCodec(() => Hash)], ['transaction', lib.toCodec(() => CommittedTransaction)]]))
export type TransactionRejectionReason = lib.Enumerate<{ AccountDoesNotExist: [FindError], LimitCheck: [TransactionLimitError], Validation: [ValidationFail], InstructionExecution: [InstructionExecutionFail], WasmExecution: [WasmExecutionFail] }>
export const TransactionRejectionReason = { /** Produce `AccountDoesNotExist` enum variant */ AccountDoesNotExist: (value: FindError): TransactionRejectionReason => lib.variant('AccountDoesNotExist', value), /** Produce `LimitCheck` enum variant */ LimitCheck: (value: TransactionLimitError): TransactionRejectionReason => lib.variant('LimitCheck', value), /** Produce `Validation` enum variant */ Validation: (value: ValidationFail): TransactionRejectionReason => lib.variant('Validation', value), /** Produce `InstructionExecution` enum variant */ InstructionExecution: (value: InstructionExecutionFail): TransactionRejectionReason => lib.variant('InstructionExecution', value), /** Produce `WasmExecution` enum variant */ WasmExecution: (value: WasmExecutionFail): TransactionRejectionReason => lib.variant('WasmExecution', value), [lib.symbolCodec]: lib.enumCodec<TransactionRejectionReason>([[0, 'AccountDoesNotExist', lib.toCodec(() => FindError)], [1, 'LimitCheck', lib.toCodec(() => TransactionLimitError)], [2, 'Validation', lib.toCodec(() => ValidationFail)], [3, 'InstructionExecution', lib.toCodec(() => InstructionExecutionFail)], [4, 'WasmExecution', lib.toCodec(() => WasmExecutionFail)]]) }
export type TransactionStatus = lib.Enumerate<{ Queued: [], Expired: [], Approved: [], Rejected: [TransactionRejectionReason] }>
export const TransactionStatus = { /** `Queued` enum variant */ Queued: lib.variant<TransactionStatus>('Queued'), /** `Expired` enum variant */ Expired: lib.variant<TransactionStatus>('Expired'), /** `Approved` enum variant */ Approved: lib.variant<TransactionStatus>('Approved'), /** Produce `Rejected` enum variant */ Rejected: (value: TransactionRejectionReason): TransactionStatus => lib.variant('Rejected', value), [lib.symbolCodec]: lib.enumCodec<TransactionStatus>([[0, 'Queued'], [1, 'Expired'], [2, 'Approved'], [3, 'Rejected', lib.toCodec(() => TransactionRejectionReason)]]) }
export type Transfer<T0, T1, T2> = { source: T0, object: T1, destination: T2 }
export const Transfer = { with: <T0, T1, T2>(codec0: lib.Codec<T0>,codec1: lib.Codec<T1>,codec2: lib.Codec<T2>): lib.Codec<Transfer<T0, T1, T2>> => { return lib.structCodec([['source', codec0], ['object', codec1], ['destination', codec2]]) } }
export type TransferBox = lib.Enumerate<{ Domain: [Transfer<AccountId, DomainId, AccountId>], AssetDefinition: [Transfer<AccountId, AssetDefinitionId, AccountId>], Asset: [AssetTransferBox] }>
export const TransferBox = { /** Produce `Domain` enum variant */ Domain: (value: Transfer<AccountId, DomainId, AccountId>): TransferBox => lib.variant('Domain', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: Transfer<AccountId, AssetDefinitionId, AccountId>): TransferBox => lib.variant('AssetDefinition', value), /** Produce `Asset` enum variant */ Asset: (value: AssetTransferBox): TransferBox => lib.variant('Asset', value), [lib.symbolCodec]: lib.enumCodec<TransferBox>([[0, 'Domain', lib.toCodec(() => Transfer.with(lib.toCodec(() => AccountId), lib.toCodec(() => DomainId), lib.toCodec(() => AccountId)))], [1, 'AssetDefinition', lib.toCodec(() => Transfer.with(lib.toCodec(() => AccountId), lib.toCodec(() => AssetDefinitionId), lib.toCodec(() => AccountId)))], [2, 'Asset', lib.toCodec(() => AssetTransferBox)]]) }
export type Trigger = { id: TriggerId; action: Action; }
export const Trigger = lib.wrapCodec<Trigger>(lib.structCodec([['id', lib.toCodec(() => TriggerId)], ['action', lib.toCodec(() => Action)]]))
export type TriggerCompletedEvent = { triggerId: TriggerId; outcome: TriggerCompletedOutcome; }
export const TriggerCompletedEvent = lib.wrapCodec<TriggerCompletedEvent>(lib.structCodec([['triggerId', lib.toCodec(() => TriggerId)], ['outcome', lib.toCodec(() => TriggerCompletedOutcome)]]))
export type TriggerCompletedEventFilter = { triggerId: lib.codecs.Option<TriggerId>; outcomeType: lib.codecs.Option<TriggerCompletedOutcomeType>; }
export const TriggerCompletedEventFilter = lib.wrapCodec<TriggerCompletedEventFilter>(lib.structCodec([['triggerId', lib.codecs.Option.with(lib.toCodec(() => TriggerId))], ['outcomeType', lib.codecs.Option.with(lib.toCodec(() => TriggerCompletedOutcomeType))]]))
export type TriggerCompletedOutcome = lib.Enumerate<{ Success: [], Failure: [lib.codecs.String] }>
export const TriggerCompletedOutcome = { /** `Success` enum variant */ Success: lib.variant<TriggerCompletedOutcome>('Success'), /** Produce `Failure` enum variant */ Failure: (value: lib.codecs.String): TriggerCompletedOutcome => lib.variant('Failure', value), [lib.symbolCodec]: lib.enumCodec<TriggerCompletedOutcome>([[0, 'Success'], [1, 'Failure', lib.toCodec(lib.codecs.String)]]) }
export type TriggerCompletedOutcomeType = lib.Enumerate<{ Success: [], Failure: [] }>
export const TriggerCompletedOutcomeType = { /** `Success` enum variant */ Success: lib.variant<TriggerCompletedOutcomeType>('Success'), /** `Failure` enum variant */ Failure: lib.variant<TriggerCompletedOutcomeType>('Failure'), [lib.symbolCodec]: lib.enumCodec<TriggerCompletedOutcomeType>([[0, 'Success'], [1, 'Failure']]) }
export type TriggerEvent = lib.Enumerate<{ Created: [TriggerId], Deleted: [TriggerId], Extended: [TriggerNumberOfExecutionsChanged], Shortened: [TriggerNumberOfExecutionsChanged], MetadataInserted: [MetadataChanged<TriggerId>], MetadataRemoved: [MetadataChanged<TriggerId>] }>
export const TriggerEvent = { /** Produce `Created` enum variant */ Created: (value: TriggerId): TriggerEvent => lib.variant('Created', value), /** Produce `Deleted` enum variant */ Deleted: (value: TriggerId): TriggerEvent => lib.variant('Deleted', value), /** Produce `Extended` enum variant */ Extended: (value: TriggerNumberOfExecutionsChanged): TriggerEvent => lib.variant('Extended', value), /** Produce `Shortened` enum variant */ Shortened: (value: TriggerNumberOfExecutionsChanged): TriggerEvent => lib.variant('Shortened', value), /** Produce `MetadataInserted` enum variant */ MetadataInserted: (value: MetadataChanged<TriggerId>): TriggerEvent => lib.variant('MetadataInserted', value), /** Produce `MetadataRemoved` enum variant */ MetadataRemoved: (value: MetadataChanged<TriggerId>): TriggerEvent => lib.variant('MetadataRemoved', value), [lib.symbolCodec]: lib.enumCodec<TriggerEvent>([[0, 'Created', lib.toCodec(() => TriggerId)], [1, 'Deleted', lib.toCodec(() => TriggerId)], [2, 'Extended', lib.toCodec(() => TriggerNumberOfExecutionsChanged)], [3, 'Shortened', lib.toCodec(() => TriggerNumberOfExecutionsChanged)], [4, 'MetadataInserted', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => TriggerId)))], [5, 'MetadataRemoved', lib.toCodec(() => MetadataChanged.with(lib.toCodec(() => TriggerId)))]]) }
export type TriggerEventFilter = { idMatcher: lib.codecs.Option<TriggerId>; eventSet: TriggerEventSet; }
export const TriggerEventFilter = lib.wrapCodec<TriggerEventFilter>(lib.structCodec([['idMatcher', lib.codecs.Option.with(lib.toCodec(() => TriggerId))], ['eventSet', lib.toCodec(() => TriggerEventSet)]]))
export type TriggerEventSet = lib.codecs.U32
export const TriggerEventSet = { /** `Created` event bitmask. Use `|` to combine with other {@link TriggerEventSet} bitmasks. */ Created: 1, /** `Deleted` event bitmask. Use `|` to combine with other {@link TriggerEventSet} bitmasks. */ Deleted: 2, /** `Extended` event bitmask. Use `|` to combine with other {@link TriggerEventSet} bitmasks. */ Extended: 4, /** `Shortened` event bitmask. Use `|` to combine with other {@link TriggerEventSet} bitmasks. */ Shortened: 8, /** `MetadataInserted` event bitmask. Use `|` to combine with other {@link TriggerEventSet} bitmasks. */ MetadataInserted: 16, /** `MetadataRemoved` event bitmask. Use `|` to combine with other {@link TriggerEventSet} bitmasks. */ MetadataRemoved: 32, [lib.symbolCodec]: lib.toCodec(lib.codecs.U32) }
export type TriggerId = { name: lib.codecs.String; }
export const TriggerId = lib.wrapCodec<TriggerId>(lib.structCodec([['name', lib.toCodec(lib.codecs.String)]]))
export type TriggerNumberOfExecutionsChanged = { trigger: TriggerId; by: lib.codecs.U32; }
export const TriggerNumberOfExecutionsChanged = lib.wrapCodec<TriggerNumberOfExecutionsChanged>(lib.structCodec([['trigger', lib.toCodec(() => TriggerId)], ['by', lib.toCodec(lib.codecs.U32)]]))
export type TriggeringEventFilterBox = lib.Enumerate<{ Pipeline: [PipelineEventFilterBox], Data: [DataEventFilter], Time: [ExecutionTime], ExecuteTrigger: [ExecuteTriggerEventFilter] }>
export const TriggeringEventFilterBox = { /** Produce `Pipeline` enum variant */ Pipeline: (value: PipelineEventFilterBox): TriggeringEventFilterBox => lib.variant('Pipeline', value), /** Produce `Data` enum variant */ Data: (value: DataEventFilter): TriggeringEventFilterBox => lib.variant('Data', value), /** Produce `Time` enum variant */ Time: (value: ExecutionTime): TriggeringEventFilterBox => lib.variant('Time', value), /** Produce `ExecuteTrigger` enum variant */ ExecuteTrigger: (value: ExecuteTriggerEventFilter): TriggeringEventFilterBox => lib.variant('ExecuteTrigger', value), [lib.symbolCodec]: lib.enumCodec<TriggeringEventFilterBox>([[0, 'Pipeline', lib.toCodec(() => PipelineEventFilterBox)], [1, 'Data', lib.toCodec(() => DataEventFilter)], [2, 'Time', lib.toCodec(() => ExecutionTime)], [3, 'ExecuteTrigger', lib.toCodec(() => ExecuteTriggerEventFilter)]]) }
export type TypeError = lib.Enumerate<{ AssetValueType: [AssetValueTypeMismatch], NumericAssetValueTypeExpected: [AssetValueType], StoreAssetValueTypeExpected: [AssetValueType] }>
export const TypeError = { /** Produce `AssetValueType` enum variant */ AssetValueType: (value: AssetValueTypeMismatch): TypeError => lib.variant('AssetValueType', value), /** Produce `NumericAssetValueTypeExpected` enum variant */ NumericAssetValueTypeExpected: (value: AssetValueType): TypeError => lib.variant('NumericAssetValueTypeExpected', value), /** Produce `StoreAssetValueTypeExpected` enum variant */ StoreAssetValueTypeExpected: (value: AssetValueType): TypeError => lib.variant('StoreAssetValueTypeExpected', value), [lib.symbolCodec]: lib.enumCodec<TypeError>([[0, 'AssetValueType', lib.toCodec(() => AssetValueTypeMismatch)], [1, 'NumericAssetValueTypeExpected', lib.toCodec(() => AssetValueType)], [2, 'StoreAssetValueTypeExpected', lib.toCodec(() => AssetValueType)]]) }
export type Unregister<T0> = { object: T0 }
export const Unregister = { with: <T0>(codec0: lib.Codec<T0>): lib.Codec<Unregister<T0>> => { return lib.structCodec([['object', codec0]]) } }
export type UnregisterBox = lib.Enumerate<{ Peer: [Unregister<PeerId>], Domain: [Unregister<DomainId>], Account: [Unregister<AccountId>], AssetDefinition: [Unregister<AssetDefinitionId>], Asset: [Unregister<AssetId>], Role: [Unregister<RoleId>], Trigger: [Unregister<TriggerId>] }>
export const UnregisterBox = { /** Produce `Peer` enum variant */ Peer: (value: Unregister<PeerId>): UnregisterBox => lib.variant('Peer', value), /** Produce `Domain` enum variant */ Domain: (value: Unregister<DomainId>): UnregisterBox => lib.variant('Domain', value), /** Produce `Account` enum variant */ Account: (value: Unregister<AccountId>): UnregisterBox => lib.variant('Account', value), /** Produce `AssetDefinition` enum variant */ AssetDefinition: (value: Unregister<AssetDefinitionId>): UnregisterBox => lib.variant('AssetDefinition', value), /** Produce `Asset` enum variant */ Asset: (value: Unregister<AssetId>): UnregisterBox => lib.variant('Asset', value), /** Produce `Role` enum variant */ Role: (value: Unregister<RoleId>): UnregisterBox => lib.variant('Role', value), /** Produce `Trigger` enum variant */ Trigger: (value: Unregister<TriggerId>): UnregisterBox => lib.variant('Trigger', value), [lib.symbolCodec]: lib.enumCodec<UnregisterBox>([[0, 'Peer', lib.toCodec(() => Unregister.with(lib.toCodec(() => PeerId)))], [1, 'Domain', lib.toCodec(() => Unregister.with(lib.toCodec(() => DomainId)))], [2, 'Account', lib.toCodec(() => Unregister.with(lib.toCodec(() => AccountId)))], [3, 'AssetDefinition', lib.toCodec(() => Unregister.with(lib.toCodec(() => AssetDefinitionId)))], [4, 'Asset', lib.toCodec(() => Unregister.with(lib.toCodec(() => AssetId)))], [5, 'Role', lib.toCodec(() => Unregister.with(lib.toCodec(() => RoleId)))], [6, 'Trigger', lib.toCodec(() => Unregister.with(lib.toCodec(() => TriggerId)))]]) }
export type Upgrade = { executor: Executor; }
export const Upgrade = lib.wrapCodec<Upgrade>(lib.structCodec([['executor', lib.toCodec(() => Executor)]]))
export type ValidationFail = lib.Enumerate<{ NotPermitted: [lib.codecs.String], InstructionFailed: [InstructionExecutionError], QueryFailed: [QueryExecutionFail], TooComplex: [], InternalError: [] }>
export const ValidationFail = { /** Produce `NotPermitted` enum variant */ NotPermitted: (value: lib.codecs.String): ValidationFail => lib.variant('NotPermitted', value), /** Produce `InstructionFailed` enum variant */ InstructionFailed: (value: InstructionExecutionError): ValidationFail => lib.variant('InstructionFailed', value), /** Produce `QueryFailed` enum variant */ QueryFailed: (value: QueryExecutionFail): ValidationFail => lib.variant('QueryFailed', value), /** `TooComplex` enum variant */ TooComplex: lib.variant<ValidationFail>('TooComplex'), /** `InternalError` enum variant */ InternalError: lib.variant<ValidationFail>('InternalError'), [lib.symbolCodec]: lib.enumCodec<ValidationFail>([[0, 'NotPermitted', lib.toCodec(lib.codecs.String)], [1, 'InstructionFailed', lib.toCodec(() => InstructionExecutionError)], [2, 'QueryFailed', lib.toCodec(() => QueryExecutionFail)], [3, 'TooComplex'], [4, 'InternalError']]) }
export type WasmExecutionFail = { reason: lib.codecs.String; }
export const WasmExecutionFail = lib.wrapCodec<WasmExecutionFail>(lib.structCodec([['reason', lib.toCodec(lib.codecs.String)]]))
export type WasmSmartContract = { blob: lib.codecs.BytesVec; }
export const WasmSmartContract = lib.wrapCodec<WasmSmartContract>(lib.structCodec([['blob', lib.toCodec(lib.codecs.BytesVec)]]))